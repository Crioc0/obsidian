---
created: 2025-10-05 18:12
tags:
  - nestjs
repeat: spaced every 36 hours
due_at: 2025-10-26T22:26:58.168+03:00
---
# 202510051812 Перехватчики

*Ссылка на StructureNote:* [[Nest.js]]
*Ссылка на исходник или контекст (если есть):*
Перехватчики схожи с фильтрами исключений, но отвечают не за ошибки, а за результат успешного выполнения обработчика. Помимо изменения ответа, перехватчики могут выполнять действия не только после обработчика, но и до него.

Чтобы объявить перехватчик, нужно применить к классу декоратор `@Injectable` и имплементировать интерфейс `NestInterceptor`:

```ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {}
}
```

Метод `intercept` срабатывает перед выполнением обработчика и получает в качестве аргументов два параметра: `ExecutionContext` — такой же, как и в гардах; и `CallHandler` — объект, с помощью которого мы можем вызвать обработчик запроса.

Внутри метода `intercept` можно получить доступ к объекту запроса. Например, чтобы реализовать логирование доступа. Главное, чтобы `intercept` возвращал `next.handle()` — так будет вызван метод контроллера для текущего роута:

```ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();

    console.log(new Date(), request.method, request.url);

    return next.handle();
  }
}
```

`next.handle` возвращает `Observable` — поток данных с результатом выполнения запроса. А значит, вы можете использовать операторы RxJS, чтобы изменить формат ответа:

```ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable, map } from 'rxjs';

@Injectable()
export class FormatInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next
      .handle()
      .pipe(
        map(data => ({
          status: response.statusCode,
          response: data
        })
      );
  }
}
```

Перехватчик можно подключать к контроллеру с помощью декоратора `@@UseInterceptors`

```ts
import { Controller, UseFilters } from '@nestjs/common';
import { LoggingInterceptor } from '../interceptors/logging.interceptor';

@Controller('users')
@UseInterceptors(LoggingInterceptor, FormatInterceptor)
export class UsersController {}
```

Или можно подключить перехватчик глобально в `main.ts`:

```ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalInterceptors(new LoggingInterceptor());

  await app.listen(3000);
}
```

Перехватчики можно использовать в качестве мидлвар для методов контроллера. Но в отличие от мидлвар, они имеют доступ к контексту запроса и, главное, к ответу от контроллера.

### Связанные идеи:

* 

---

*Что стоит развить? Какие вопросы возникли?*
1) Что такое реактивность в контексте Nest,js
2) Что такое Observable
