---
created: 2025-10-01 12:06
tags:
  - security
  - express
---
# 202510011206
*Ссылка на StructureNote:*[[02 Structure notes/Express|Express]]
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/learn/backend-nodejs/courses/16b47298-e20d-4fde-9619-1ab305039a00/sprints/564238/topics/511a777e-323b-4964-9150-d06eaeb48080/lessons/f2ee2f68-b5ab-4c25-b838-cb0496fb17a8/)

### Настройте заголовки ответа
Есть ряд заголовков, отвечающих за разные аспекты безопасности. Вы уже знакомы с Content-Security-Policy, которые позволяют ограничить источники скриптов и других ресурсов.

```ts
const helmet = require('helmet');

app.use(helmet());
```
### Проверяйте, какие данные присылает пользователь
Валидируйте данные на входе и заменяйте управляющие символы мнемониками. Если фронтенд вставляет их в сайт небезопасно, перед вставкой обрабатывайте данные. Для этого можно использовать `escape-html`. Например, так:
```ts
let escape = require('escape-html');
// в переменной html лежат уже приведённые в безопасную форму данные
let html = escape('foo & bar'); 
```
### Думайте о том, где хранятся данные на клиенте
LocalStorage удобен и прост. Он отлично подойдёт для хранения данных, которые нет нужды скрывать. Но к localStorage есть доступ из JavaScript-кода, и это поведение нельзя запретить.

Для хранения секретных данных лучше подходят httpOnly-куки. При использовании модуля `cookie-parser` необходимо указать соответствующую опцию при установке значения:
```ts
res.cookie('JWT', 'YOUR_TOKEN_HERE', {
httpOnly: true
});
```
### Помните о CSRF

Если ваш сервис при авторизации запросов опирается на автоматическую отправку кук браузером, реализуйте хотя бы простейшую защиту от CSRF. В этом поможет опция same site.

Для этого задайте соответствующий флаг-опцию при установке значения:
```ts
res.cookie('JWT', 'YOUR_TOKEN_HERE', {
sameSite: true
});
```

### Связанные идеи:
* 
---

*Что стоит развить? Какие вопросы возникли?*