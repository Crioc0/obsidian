---
created: 2025-10-03 13:55
tags:
  - nestjs
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510031355 Внедрение провайдеров через класс nestJS

*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/trainer/backend-nodejs/lesson/22418348-d1ed-4fa8-a344-022f984ddf6d/task/e3e1075f-74d4-45b0-bf1d-4f4a07eebc4a/)

Провайдером может быть любой класс, который обёрнут в декоратор `@Injectable()`. Благодаря этому декоратору класс может быть внедрён как зависимость в любой другой компонент Nest.js.

```ts
// users.service.ts

import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  get(id: string): string {
    return 'This method will return a user';
  }
}
```

Чтобы Nest.js узнал о нашем провайдере, его необходимо зарегистрировать в модуле. Сразу свяжем провайдер с контроллером

```ts
// users.module.ts

import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}
```

Когда используется декоратор `@Injectable`, провайдер регистрируется с использованием сокращенной записи

```ts
@Module({
  providers: [UsersService],
})
export class UsersModule {}
```

Без использования декоратора можно использовать равносильную запись для регистрации контроллера

```ts
@Module({
  providers: [{
    provide: UsersService,
    useClass: UsersService,
  }]
})
export class UsersModule {}
```

Сила внедрения зависимостей в том, что помимо классов-сервисов мы можем внедрять абсолютно любые значения или даже заменить провайдер на другой.

```ts
@Module({
  providers: [{
    provide: UsersService,
    // заменяем сервис на мок для тестирования
    useClass: userServiceMock,
  }]
})
export class UsersModule {}
```

После регистрации можно использовать провайдер внутри контроллера в этом же модуле. Достаточно указать провайдер как аргумент конструктора.

Чтобы использовать провайдер внутри другого провайдера, нужно сделать то же самое:

1. зарегистрировать провайдер в модуле,
2. указать его как аргумент конструктора другого провайдера.

#### **Пример подобного подключения**

**Модуль**

```ts
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { UsersRepository } from './users.repository';

@Module({
  providers: [UsersService, UsersRepository],
  controllers: [UsersController],
})
export class UsersModule {}
```

**Провайдер**

```ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  constructor(private readonly usersRepository: UsersRepository) {}

  async get(id: string) {
    const user = await this.usersRepository.get(id);

    delete user.password;

    return user;
  }
}
```

С помощью провайдеров можно внедрять не только классы, но и обычные объекты, к примеру, с конфигурацией приложения. Или можно даже использовать функции-фабрики, чтобы генерировать значения провайдера на лету.

### Связанные идеи:

* [[202510022039 Провайдеры, или сервисы]]

---

*Что стоит развить? Какие вопросы возникли?*
