---
created: 2025-10-08 13:20
tags:
  - vue
---
# 202510081320
*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):* 

Созданные пользователем обратные вызовы обрабатываются пакетно, чтобы избежать дублирования. Например, мы, вероятно, не хотим, чтобы наблюдатель запускался тысячу раз, если мы синхронно помещаем тысячу элементов в отслеживаемый массив.

По умолчанию, созданные пользователем обратные вызовы наблюдателей вызываются **до** обновления компонентов Vue. Это означает, что если вы попытаетесь получить доступ к DOM внутри обратного вызова наблюдателя, DOM будет находиться в состоянии до того, как Vue применит какие-либо обновления.

### Post Watchers
Если вы хотите получить доступ к DOM в обратном вызове наблюдателя **после того**, как Vue обновит его, вам нужно указать опцию `flush: 'post'`:

```js
watch(source, callback, {
  flush: 'post'
})

watchEffect(callback, {
  flush: 'post'
})
```

Post-flush `watchEffect()` также имеет удобный псевдоним, `watchPostEffect()`:
```js
import { watchPostEffect } from 'vue'

watchPostEffect(() => {
  /* выполняется после обновлений Vue */
})
```

### Sync watchers
Также можно создать наблюдатель, который будет срабатывать синхронно, перед любыми обновлениями, управляемыми Vue:`
```js
watch(source, callback, {
  flush: 'sync'
})

watchEffect(callback, {
  flush: 'sync'
})
```
У синхронных `watchEffect()` также есть удобный псевдоним, `watchSyncEffect()`:
```js
import { watchSyncEffect } from 'vue'

watchSyncEffect(() => {
  /* выполняется синхронно при изменении реактивных данных */
})
```
Используйте с осторожностью

Синхронные наблюдатели не имеют пакетной обработки и срабатывают каждый раз, когда обнаруживается реактивная мутация. Их можно использовать для наблюдения за простыми булевыми значениями, но избегайте их использования для источников данных, которые могут синхронно изменены много раз, например, массивов.
# Связанные идеи:
* [[202510081310 Наблюдатели Vue]]
---

*Что стоит развить? Какие вопросы возникли?*