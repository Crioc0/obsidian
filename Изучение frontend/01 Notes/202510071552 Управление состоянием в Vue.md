---
created: 2025-10-07 15:52
tags:
  - vue
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510071552 Управление состоянием в Vue

*Ссылка на StructureNote:* [[02 Structure notes/Vue|Vue]]
*Ссылка на исходник или контекст (если есть):* 

Технически каждый экземпляр компонента Vue уже "управляет" своим реактивным состоянием. Возьмём для примера простой компонент счетчика:

```js
<script setup>
import { ref } from 'vue'

// состояние
const count = ref(0)

// действия
function increment() {
  count.value++
}
</script>

<!-- представление -->
<template>{{ count }}</template>
```

Это самостоятельный блок, состоящий из следующих частей:

- **Состояние** - источник данных, который управляет нашим приложением;
- **Представление** - декларативное отображение **состояния**;
- **Действия** - возможные способы изменения состояния в ответ на пользовательский ввод из **представления**.
Это простое представление концепции "одностороннего потока данных"
Однако эта простота начинает нарушаться, когда у нас есть **несколько компонентов, имеющих общее состояние**:

1. Несколько представлений могут зависеть от одного и того же фрагмента состояния.
2. Действиям из разных представлений может потребоваться мутировать один и тот же фрагмент состояния.
В первом случае возможным обходным путем является "поднятие" общего состояния до общего компонента-предка, а затем передача его вниз в виде входных параметров. В случае глубокой иерархии приводит к prop drilling

Во втором случае мы часто прибегаем к таким решениям, как обращение к прямым родительским и дочерним экземплярам через ссылки на элементы шаблона или попытка мутировать и синхронизировать несколько копий состояния через генерируемые события. Оба эти паттерна являются хрупкими и быстро приводят к сложно поддерживаемому коду.

# Связанные идеи:

* 
---

*Что стоит развить? Какие вопросы возникли?*
