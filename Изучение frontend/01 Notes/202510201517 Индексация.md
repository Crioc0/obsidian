---
created: 2025-10-20 15:17
tags:
  - 
---
# 202510201517 Индексация

*Ссылка на StructureNote:* [[Database]]
*Ссылка на исходник или контекст (если есть):* 

Чтобы от первичного ключа таблицы была польза, необходимо иметь возможность быстро получить запись по ID. Для этого СУБД строит вспомогательный индекс, содержащий ID строк, и соответствующие им адреса в памяти .По сути, индекс — это сбалансированное двоичное дерево поиска (см. раздел «Структуры» предыдущей главы). Каждая строка в таблице соответствует узлу в дереве.

![[Индекс в базе данных.png]]

Ключи узлов — это значения в индексируемом поле. Чтобы найти запись с заданным значением, мы ищем его в дереве. Найдя узел, мы получаем адрес, который он хранит, и используем его для выборки.

Базу данных можно представить как базу данных. При добавлении данных все будет работать быстро, так добавление будет в конец массива. При чтении нужно будет пройти все элементы массива, чтобы найти те, что подходят под фильтр. Каждая новая запись в в базе данных увеличивает время поиска. Поиск будет вестись со скоростью O(n)

Для того, чтобы ускорить поиск данных в базе, нужно заменить структуру массива на более эффективную при чтении. Для этого используются деревья поиска, чаще всего B-деревья, которые работают со скоростью O(logN). Такое дерево и называют индексом. В индексе хранится значение поля и ссылка на соответствующий ему документ.

Индекс можно построить только по одному полю из документа. При создании индекса  можно быстро искать данные по этому полю.

Но если потребуется найти данные по другому полю, придется по прежнему перебирать каждую запись. При этом обход по дереву будет сложнее, чем обход по массиву. Поэтому документы в коллекции хранятся как массив, а индексы хранятся отдельно от коллекции и содержат в себе ссылки на оригинальные документы

При запросах MongoDB использует тот индекс, который точнее соответствует фильтру.

Обычно СУБД создает индекс для каждого первичного ключа в базе данных. Но если часто приходится искать записи по другим полям (например, искать клиентов по именам), можно поручить СУБД создать для них дополнительные индексы.

- **Ограничения уникальности** При помощи индекса можно быстро выполнить поиск и, например, обнаружить, что значение, которое мы пытаемся вставить, уже присутствует. Индексация полей, имеющих ограничение уникальности, необходима для быстрой вставки элементов.
- **Сортировка** Индексы помогают выбирать строки в порядке сортировки по индексированным полям. Например, если имеется индекс для поля name («имя»), мы можем получить строки, отсортированные по имени, без дополнительных вычислений. Если применить команду ORDER BY к полю без индекса, СУБД придется отсортировать данные в памяти, прежде чем выполнить запрос. Многие СУБД могут даже отказаться выполнять запрос, требующий произвести сортировку по неиндексированному полю, если в работу будет вовлечено слишком много строк
- **Производительновсть** индексы — это круто: они позволяют делать сверхбыстрые запросы и мгновенно получать доступ к отсортированным данным. Тогда почему у нас нет индексов для всех полей в каждой таблице? Проблема в том, что, когда новая запись вставляется в таблицу или удаляется из нее, приходится обновлять все индексы, чтобы отразить это изменение. Если индексов много, то обновление, вставка или удаление строк могут стать в вычислительном плане дорогостоящими операциями (вспомним про балансировку дерева). Более того, индексы занимают ограниченное дисковое пространство.

# Связанные идеи 

- [[202509241516 Понятие индекса в СУБД]] 
- [[202509241122 Индексы в MongoDB]]
---

*Что стоит развить? Какие вопросы возникли?*
