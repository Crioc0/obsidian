---
repeat: spaced every 24 hours
created: 2025-10-20 15:17
tags:
  - 
due_at: 2025-10-24T10:45:34.025+03:00
---
# 202510201517 Индексация

*Ссылка на StructureNote:* [[Database]]
*Ссылка на исходник или контекст (если есть):*

**Проблема: Медленный поиск без индекса**

Исходную базу данных можно представить как простой массив записей.

- **Добавление** новых данных происходит быстро, так как записи просто добавляются в конец.
- **Поиск** (например, по фильтру) требует полного перебора всех элементов массива. Каждая новая запись увеличивает время поиска. Такой алгоритм имеет сложность **O(n)**, что становится очень медленным при больших объемах данных.

**Решение: Индексы для ускорения поиска**

Чтобы ускорить чтение, структуру хранения данных для поиска заменяют на более эффективную. Чаще всего для этого используются **B-деревья** (сбалансированные деревья поиска), которые обеспечивают поиск со сложностью **O(log n)**. Эта структура и называется **индексом**.

![[Индекс в базе данных.png]]

- В индексе хранятся пары "ключ - значение":
    - **Ключ** — значение проиндексированного поля (например, ID или имя).
    - **Значение** — ссылка на адрес соответствующей записи (документа) в памяти или на диске.
- Чтобы найти запись по значению поля, СУБД выполняет быстрый поиск по дереву, находит узел с нужным ключом, получает адрес и использует его для прямой выборки данных.

### **Дополнительные преимущества индексов**

Помимо ускорения поиска, индексы решают и другие важные задачи:

1. **Обеспечение ограничения уникальности**
    Индекс позволяет мгновенно проверить, существует ли уже вставляемое значение в таблице. Это необходимо для реализации ограничений уникальности (например, `UNIQUE CONSTRAINT` в SQL) и предотвращения дубликатов.
    
2. **Ускорение операций сортировки (ORDER BY)**
    Если данные нужно получить в отсортированном по индексированному полю виде, СУБД может просто последовательно обойти дерево в нужном порядке, уже хранящее данные отсортированными. Без индекса СУБД пришлось бы загружать все данные в память и выполнять дорогостоящую операцию сортировки "на лету". Некоторые СУБД могут даже отказаться выполнять сортировку по неиндексированному полю для больших наборов данных.

### **Цена использования индексов и ограничения**

Индексы — это мощный инструмент, но у них есть и обратная сторона. Почему же не проиндексировать все поля?

- **Снижение производительности при операциях записи:** При каждой **вставке, обновлении или удалении** записи все индексы, связанные с этой таблицей,也必须 быть обновлены. Каждое такое изменение в индексе требует вычислительных затрат на перебалансировку дерева. Большое количество индексов может сделать операции записи очень медленными.
- **Затраты дискового пространства:** Индексы занимают место на диске. Чем больше индексов и чем крупнее таблица, тем больше места они потребуют.

**Вывод:** Индексы следует создавать обдуманно — для тех полей, которые часто используются в условиях поиска (`WHERE`), соединениях (`JOIN`) или сортировки (`ORDER BY`), балансируя между скоростью чтения и стоимостью операций записи.

# Связанные идеи

- [[202509241122 Индексы в MongoDB]]

---

*Что стоит развить? Какие вопросы возникли?*
