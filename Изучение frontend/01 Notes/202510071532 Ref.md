---
created: 2025-10-07 15:32
tags:
  - vue
---
# 202510071532
*Ссылка на StructureNote:* 
*Ссылка на исходник или контекст (если есть):* 

В compositionAPI рекомендуемым способом объявления реактивного состояния является использование ref() функции
`ref()` принимает аргумент и возвращает его завёрнутым в объект ref со свойством `.value`:
```js
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```
 Для удобства ref автоматически "разворачиваются" при использовании внутри шаблонов

Свойство `.value` дает Vue возможность обнаружить, когда к ссылке обращались или она была изменена. Под капотом Vue выполняет отслеживание в геттере, а срабатывание - в сеттере. Концептуально, вы можете представить себе ref как объект, который выглядит следующим образом:
```js
// псевдокод, а не реальная реализация
const myRef = {
  _value: 0,
  get value() {
    track()
    return this._value
  },
  set value(newValue) {
    this._value = newValue
    trigger()
  }
}
```
Рефы могут содержать значения любого типа, включая глубоко вложенные объекты, массивы или встроенные в JavaScript структуры данных типа `Map`.

Ссылка делает своё значение глубоко реактивным. Это означает, что вы можете ожидать обнаружения изменений даже при мутации вложенных объектов или массивов
```js
import { ref } from 'vue'

const obj = ref({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // они будут работать, как и ожидалось.
  obj.value.nested.count++
  obj.value.arr.push('baz')
}
```
# Связанные идеи:
* [[202510071530 Как работает реактивность во Vue]]
---

*Что стоит развить? Какие вопросы возникли?*