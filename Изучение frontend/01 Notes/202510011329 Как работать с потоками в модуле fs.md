---
created: 2025-10-01 13:29
tags:
  - nodejs
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510011329 Как работать с потоками в модуле fs

*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/learn/backend-nodejs/courses/16b47298-e20d-4fde-9619-1ab305039a00/sprints/564238/topics/57910525-b12b-4241-8764-6b23c37a80fc/lessons/cfdcffd9-668b-4969-b37d-a99b7d93f74e/)

В модуле `fs` есть методы `createReadStream` и `createWriteStream`. Они создают потоки для чтения и записи соответственно. Первым аргументом методы принимают путь к файлу, а вторым — объект опций, где можно передать, например, кодировку

Чтобы скомбинировать потоки чтения и записи, то есть превратить их в дуплексный поток, нужно при каждом событии `data` потока чтения вносить порцию данных в поток записи. Когда данные полностью прочитаны, поток для чтения сгенерирует событие `end`. Его нужно обработать и сообщить потоку записи, что все данные пришли и ничего больше записывать не нужно. Для этого у потока записи есть метод `end`. Последнее, что нужно сделать — обработать ошибку. В случае ошибки поток для чтения сгенерирует событие `error`. Его нужно обработать:

```ts
import fs from 'fs';

const reader = fs.createReadStream('./in.txt', { encoding: 'utf8' });
const writer = fs.createWriteStream('./out.txt', { encoding: 'utf8' });

reader.on('data', (data) => {
  writer.write(data);
});

reader.on('end', (data) => {
  writer.end();
});

// повесим обработчик события error
reader.on('error', (err) => {
  console.log(err);
});
```

### Метод pipe для работы с потоками

Чтобы организовать простейшую работу с двумя потоками, мы добавили три обработчика событий. Но код можно сделать заметно короче, если воспользоваться специальным методом для комбинирования потоков — `pipe`. Вам даже не нужно закрывать потоки и обрабатывать ошибки — вся эта логика уже описана внутри метода `pipe. Метод `pipe` есть только у потоков для чтения — поток для записи передают как аргумент. Обращение пользователя к серверу — тоже поток для чтения, так что мы можем обработать этот запрос методом `pipe`:

```ts
import http from 'http';
import { IncomingMessage, ServerResponse } from 'http';
import fs from 'fs';

const server = http.createServer((req:IncomingMessage, res:ServerResponse) => {
  req.pipe(fs.createWriteStream(`./out-${Math.random()}.txt`));
});

server.listen(3000);
```

### Связанные идеи:

* [[202510011328 Потоки для чтения и записи файлов в NodeJS]]
* [[202510011303 Работа с файловой системой, модуль fs]]

---

*Что стоит развить? Какие вопросы возникли?*
