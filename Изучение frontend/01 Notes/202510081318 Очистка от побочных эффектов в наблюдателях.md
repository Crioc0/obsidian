---
created: 2025-10-08 13:18
tags:
  - vue
---
# 202510081318
*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):* 

Иногда мы можем получить побочные эффекты, например при асинхронных запросах:
```js
watch(id, (newId) => {
  fetch(`/api/${newId}`).then(() => {
    // callback logic
  })
})
```
Но что, если `id` изменится до завершения запроса? Когда запрос завершится, мы получим данные с предыдущем запрошенным значением. В идеале, мы хотим иметь возможность отменить запрос, при изменении `id`.

Мы можем использовать [`onWatcherCleanup()`](https://ru.vuejs.org/api/reactivity-core.html#onwatchercleanup)  API для регистрации функции очистки, которая будет вызываться, когда наблюдатель становится недействительным и собирается перезапуститься:
```js
import { watch, onWatcherCleanup } from 'vue'

watch(id, (newId) => {
  const controller = new AbortController()

  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // callback logic
  })

  onWatcherCleanup(() => {
    // abort stale request
    controller.abort()
  })
})
```
Обратите внимание, что `onWatcherCleanup` поддерживается только в Vue 3.5+ и должен вызываться во время синхронного вызова функции эффекта `watchEffect` или обратного вызова `watch`. Ты не сможешь его вызвать после `await` в асинхронной функции.

Альтернативно, функция `onCleanup` передается в коллбэк `watch` в качестве третьего аргумента, и в коллбэк `watchEffect` в качестве первого аргумента:
```js
watch(id, (newId, oldId, onCleanup) => {
  // ...
  onCleanup(() => {
    // cleanup logic
  })
})

watchEffect((onCleanup) => {
  // ...
  onCleanup(() => {
    // cleanup logic
  })
})
```
Это работает в версии до 3.5. Кроме того, `onCleanup`, передаваемый через аргумент функции, привязан к экземпляру наблюдателя, поэтому на него не распространяется синхронное ограничение `onWatcherCleanup`.

# Связанные идеи:
* [[202510081310 Наблюдатели Vue]]
---

*Что стоит развить? Какие вопросы возникли?*