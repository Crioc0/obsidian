---
repeat: spaced every day
created: 2025-10-21 13:32
tags:
  - 
---
# 202510211332 Декларативное программирование

*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):*

**Декларативная парадигма** фокусируется на том, _что_ нужно сделать, а не на том, _как_ это сделать. Это позволяет писать более короткие, простые и читаемые программы.

**Функциональное программирование (ФП)** — это подход, в котором функции являются объектами первого класса. Это означает, что с ними можно работать как с любыми другими данными: передавать в другие функции, возвращать их как результат и т.д.

**Ключевые концепции ФП:**

1. **Функции высшего порядка** — это функции, которые принимают или возвращают другие функции. Они лежат в основе ФП и используются для основных операций с коллекциями:
    
    - **`map` (отображение):** Применяет функцию к каждому элементу коллекции.
        - Пример: `squared_numbers = map(numbers, square)` — получить список квадратов.
    - **`filter` (фильтрация):** Отбирает элементы, удовлетворяющие условию.
        - Пример: `odd_numbers = filter(numbers, is_odd)` — оставить только нечётные числа.
    - **`reduce` (свёртка):** Превращает коллекцию в единственное значение, последовательно применяя функцию.
        - Пример: `sum = reduce(numbers, 0, add)` — вычислить сумму всех чисел.

    Для удобства во многих языках существует "синтаксический сахар" (например, списковые включения в Python), делающий запись этих операций короче.

2. **Замыкания** — это функции, которые "помнят" окружение, в котором были созданы. Они позволяют:
    
    - **Каррирование:** Преобразование функции от многих аргументов в последовательность функций от одного аргумента.
        - Пример: `sum_three = sum(3); sum_three(1) // вернёт 4`
    - **Создание функций-генераторов:** Создание нескольких функций по одному шаблону.
        - Пример: `square = power_generator(2); square(2) // вернёт 4`
    - **Инкапсуляция состояния:** Замена глобальных переменных на приватное состояние внутри функции.
        - Пример: Создание счётчика `my_adder = make_adder()`, который хранит свою сумму внутри.
            
3. **Сопоставление с образцом** позволяет определять поведение функции через шаблоны её аргументов, что делает код декларативным и похожим на математические определения.
    
    - Функциональный стиль: `factorial(0): 1 factorial(n): n * factorial(n-1)`
    - Такой код часто читается проще, чем императивный аналог с условиями `if-else`.

**Итог:** Функциональное программирование предлагает мощные инструменты для написания лаконичного, выразительного и надёжного кода, основанные на использовании чистых функций, отсутствии изменяемого состояния и работе с функциями как с данными.

# Связанные идеи

- [[202510211325 Парадигмы программирования]]

---

*Что стоит развить? Какие вопросы возникли?*
