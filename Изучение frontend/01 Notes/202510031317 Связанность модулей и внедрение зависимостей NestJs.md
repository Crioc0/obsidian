---
created: 2025-10-03 13:17
tags:
  - nestjs
  - уровень_1
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510031317 Связанность модулей и внедрение зависимостей NestJs

*Ссылка на StructureNote:* [[Nest.js]]
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/trainer/backend-nodejs/lesson/8ab54f1a-884d-49fd-9ddd-61c4c96b35a7/)

Меру того, насколько модули связаны друг с другом, называют связанностью(coupling).

Связанность может быть слабой или сильной. Если внесение изменений в один модуль требует изменений в другом модуле, то эти два модуля сильно связаны. Модули с сильной связью трудно повторно использовать и тестировать.

Пример модулей с сильной зависимостью

**Контроллер**

```ts
// users.controller.ts

import { Controller, Get, Param } from '@nestjs/common';

@Controller('users')
export class UsersController {
  @Get(':id')
  public get(@Param('id') id: number) {
    return 'This action will return user';
  }
}
```

**Класс-репозиторий**

```ts
// users.repository.ts

export class UsersRepository {
  get(id: string): Promise<User> {
    // через переменную database можно обращаться к базе данных;
    return database.findOne({ id: id });
  }
}
```

```ts
import { Controller, Get, Param } from '@nestjs/common';
import { UsersRepository } from './users.repository';

@Controller('users')
export class UsersController {
  private readonly repository = new UsersRepository();

  @Get(':id')
  public get(@Param('id') id: string) {
    return this.repository.get(id);
  }
}
```

Контроллер в данной ситуации зависит от класса-репозитория. А `UserRepository` является зависимостью для контроллера.

Чтобы уменьшить связанность, можно применить внедрение зависимости (dependency injection).Достаточно не инициализировать репозиторий в контроллере, а передать уже инициализированный объект репозитория в конструктор.

```ts
import { Controller, Get, Param } from '@nestjs/common';
import type { UsersRepository } from './users.repository';

@Controller('users')
export class UsersController {
  constructor(private readonly repository: UsersRepository) {}
 

  @Get(':id')
  public get(@Param('id') id: string) {
    return this.repository.get(id);
  }
}
```

`UsersRepository` по-прежнему остаётся зависимостью `UsersController`. Но теперь импорт и инициализацию будет делать какой-то внешний модуль, а затем «внедрять» готовый объект в конструктор контроллера. **Внедрение зависимости снижает связанность кода**

### Связанные идеи:

* [[202510031330 Инверсия управления, IoC]]

---

*Что стоит развить? Какие вопросы возникли?*
