---
created: 2025-10-04 13:04
tags:
  - nestjs
---
# 202510041304
*Ссылка на StructureNote:* 
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/learn/backend-nodejs/courses/a4214ab0-2146-4152-b90e-651bf4c7ca5e/sprints/564244/topics/1df920a3-5c6a-4fcd-884c-0f66136c2b56/lessons/92cb7709-dd04-4796-a045-a4759a2f51e6/)


Обычная практика в бэкенде: когда все необходимые переменные выносятся в один файл — конфиг. Остаётся только поменять значения в одном месте, а не искать их по всему коду.
Один из примеров конфигурации — файл `.env`. 
Мы могли бы получить доступ к этим переменным прямо внутри провайдера:
```ts
@Injectable()
export class DatabaseConnection {
  private url = process.env.DATABASE_URL;
  private dbName = process.env.DATABASE_NAME;
}
```
Но таким образом провайдер зависим от конфига. Если в будущем вы решите заменить `.env` на другой способ конфигурации, придётся менять код в каждом файле, где `env` используется.

Можно сделать конфигурацию отдельным провайдером `ConfigProvider`, который можно внедрить в другой провайдер. Тогда при изменении способа конфигурации поменяется только `ConfigProvider`. Для этих целей в Nest.js можно внедрить провайдер не как класс, а как обычное значение или функцию-фабрику. Такие провайдеры ещё называют кастомными (от англ. custom).
Внедрить значение можно с помощью опции `useValue`.
```ts
const applicationConfig = process.env;

const configProvider = {
  provide: 'CONFIG',
  useValue: applicationConfig,
}

@Module({
  providers: [configProvider],
})
export class UsersModule {}
```
В `provide` задается идентификатор, который сможем использовать для внедрения конфигурации. В этом нам поможет декоратор `@Inject()`:
```ts
import { Controller } from '@nestjs/common';

@Controller()
export class UsersService {
  // можно обернуть свойство
  @Inject('CONFIG')
  private config: ApplicationConfig;

  // или параметр конструктора
  constructor(@Inject('CONFIG') config: ApplicationConfig) {}
}
```
Ещё можно указать в качестве значения провайдера функцию-фабрику, которая вернёт нужный нам объект. Это можно сделать с помощью опции `useFactory`. Например, таким образом мы можем внедрить объект соединения с базой данных
```ts
const databaseProvider = {
  provide: 'DATABASE',
  useFactory: (config: ApplicationConfig) => {
    const options = {
      url: config.DATABASE_URL,
      dbName: config.DATABASE_NAME,
    };

    return new DatabaseConnection(options);
  },
  // можем указать зависимости, которые нужны для функции-фабрики
  inject: [{ token: 'CONFIG' }]
}

@Module({
  providers: [databaseProvider, configProvider],
})
export class UsersModule {}
```
Каждый раз когда провайдер внедряется через `@Inject`, Nest.js будет вызывать функцию `useFactory` и использовать её результат для внедрения.

Благодаря такой гибкой системе внедрения зависимостей мы можем связывать любые два провайдера между собой. При этом нам не нужно думать о том, каким образом провайдер попадёт в контроллер или другой провайдер, об этом позаботится IoC-контейнер Nest.js.

### Связанные идеи:
* [[202510022039 Провайдеры, или сервисы]]
---

*Что стоит развить? Какие вопросы возникли?*