---
created: 2025-10-04 14:44
tags:
  - nestjs
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510041444 Динамический импорт модулей в NestJS

*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/trainer/backend-nodejs/lesson/c5752da6-232b-4382-b391-e71e86011c66/task/f5659b35-9bbb-4853-b6da-9b952816b6c5/?hideTheory=1)

При объявлении модуля вы сразу определяете контроллеры и провайдеры, которые он может использовать и экспортировать. Но иногда нужно, чтобы поведение модуля менялось в зависимости от некоторых условий.

Например, в проекте используется сразу две СУБД: MongoDB и PostgreSQL. Конечно, можно сделать отдельный модуль под каждую СУБД, но удобнее всё же будет иметь единственный `DatabaseModule`, который будет подключаться к нужной СУБД в зависимости от параметров. Тут нам на помощь приходят динамические модули.

Массив `imports` может принимать не только класс импортируемого модуля, но и функцию, которая возвращает динамический модуль:

```ts
import { Module } from '@nestjs/common';
import { DatabaseModule, DBMS } from './database/database.module';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [DatabaseModule.register(DBMS.MongoDB)],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

Функция должна быть объявлена в импортируемом модуле и возвращать объект со структурой, аналогичной параметрам модуля:

```ts
import { Module, DynamicModule } from '@nestjs/common';
import { MongoDBService } from './mongodb.service';

@Module({})
export class DatabaseModule {
  static register(): DynamicModule {
    return {
      module: DatabaseModule,
      providers: [MongoDBService],
      exports: [MongoDBService],
    }
  }
}
```

Благодаря такой функции вы определяете, какие провайдеры экспортирует модуль:

```ts

import { Module, DynamicModule } from '@nestjs/common';
import { MongoDBService } from './mongodb.service';
import { PostgreSQL } from './postgresql.service';

export enum DBMS {
  MongoDB,
  PostgreSQL,
}

@Module({})
export class DatabaseModule {
  static register(dbms: DBMS): DynamicModule {
    const providers = [];

    switch (dbms) {
      case DBMS.MongoDB:
        providers.push(MongoDBService);
        break;

      case DBMS.PostgreSQL:
      default:
        providers.push(PostgreSQLService);
        break;
    }

    return {
      module: DatabaseModule,
      providers,
      exports: providers,
    }
  }
}
```

Функция `register` может называться как угодно. Но разработчики Nest.js предлагают придерживаться единого стандарта в именовании и предлагают несколько вариантов:

- `register` — используется, если конфигурация действует только в рамках модуля, в который динамический модуль импортируется — как в нашем примере с СУБД.
- `forRoot` — используется, если конфигурация передаётся только один раз и переиспользуется в разных модулях. Часто это общая конфигурация сервера, которая зависит только от окружения. Вы сохраняете её, один раз вызвав `DatabaseModule.forRoot(options)`. А другим разработчикам не придётся думать, какую конфигурацию передавать — достаточно вызвать просто `DatabaseModule.forRoot()` без параметров.
- `forFeature` — используется вместе с `forRoot`, если общая конфигурация модуля остаётся такой же, но необходимо изменить несколько значений под конкретный модуль. Например, мы можем подключать или отключать некоторые функции только для некоторых модулей.

### Связанные идеи:

* [[202510022033 Модули в Nest.js]]
---

*Что стоит развить? Какие вопросы возникли?*
