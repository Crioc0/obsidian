---
created: 2025-10-08 13:21
tags:
  - vue
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510081321 Остановка обратного вызова

*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):*

Наблюдатели, объявленные синхронно внутри `setup()` или `<script setup>`, привязываются к экземпляру компонента-владельца и автоматически останавливаются, когда компонент-владелец размонтируется. В большинстве случаев вам не нужно беспокоиться о том, чтобы остановить наблюдателя самостоятельно.

Ключевым моментом здесь является то, что наблюдатель должен быть создан **синхронно**. Если наблюдатель будет создан в асинхронном обратном вызове, он не будет привязан к компоненту-владельцу и должен быть остановлен вручную, чтобы избежать утечки памяти. Вот пример:

```js
<script setup>
import { watchEffect } from 'vue'

// будет автоматически остановлено
watchEffect(() => {})

// ...это - нет!
setTimeout(() => {
  watchEffect(() => {})
}, 100)
</script>
```

Чтобы вручную остановить watcher, используйте функцию возврата. Это работает как для `watch`, так и для `watchEffect`:

```js
const unwatch = watchEffect(() => {})

// ...позже, когда уже не нужно
unwatch()
```

Обратите внимание, что случаев, когда вам нужно создавать наблюдатели асинхронно, должно быть очень мало, и по возможности лучше предпочесть синхронное создание. Если вам нужно дождаться асинхронных данных, вы можете сделать логику работы наблюдателя условной

# Связанные идеи:

* [[202510081310 Наблюдатели Vue]]

---

*Что стоит развить? Какие вопросы возникли?*
