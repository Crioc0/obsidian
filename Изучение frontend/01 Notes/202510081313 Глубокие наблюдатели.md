---
created: 2025-10-08 13:13
tags:
  - vue
  - уровень_1
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510081313 Глубокие наблюдатели

*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):*

Когда вы вызываете `watch()` непосредственно на реактивном объекте, он неявно создает глубокий наблюдатель - обратный вызов будет срабатывать на все вложенные мутации:

```js
const obj = reactive({ count: 0 })

watch(obj, (newValue, oldValue) => {
  // срабатывает при мутациях вложенного свойства
  // Примечание: `newValue` будет равно `oldValue`
  // потому что они оба указывают на один и тот же объект!
})

obj.count++
```

Это следует отличать от геттера, который возвращает реактивный объект — в последующих случаях обратный вызов сработает только в том случае, если геттер вернет другой объект:

```js
watch(
  () => state.someObject,
  () => {
    // сработает только при замене state.someObject
  }
)
```

Однако вы можете принудительно преобразовать второй случай в глубокий watcher, явно используя опцию `deep`:

```js
watch(
  () => state.someObject,
  (newValue, oldValue) => {
    // Примечание: `newValue` здесь будет равно `oldValue`
    // *если* state.someObject не был заменен
  },
  { deep: true }
)
```

В Vue 3.5+ опция `deep` также может быть числом, указывающим максимальную глубину обхода — то есть на сколько уровней вложенности Vue должен проходить по свойствам объекта.

# Связанные идеи:

* [[202510081310 Наблюдатели Vue]]

---

*Что стоит развить? Какие вопросы возникли?*
