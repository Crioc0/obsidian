---
created: 2025-10-07 13:53
tags:
  - javaScript
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510071353 Символы (Symbols) в JavaScript

*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):* 

## Ограничения ключей объектов

По спецификации, в качестве ключей для свойств объекта могут использоваться только:

- **Строки**
    
- **Символы**

Числа, логические значения и другие типы не подходят.

## Создание символов

**Символ** — уникальный идентификатор. Создается с помощью функции `Symbol()`:

```js
// Создаём символ id с описанием "id"
let id = Symbol('id');
```

### Особенности символов:

- **Гарантированно уникальны** (даже с одинаковым описанием)
    
- **Описание** — только метка для отладки, не влияет на уникальность

```js
let id1 = Symbol('id');
let id2 = Symbol('id');

alert(id1 == id2); // false - разные символы
```

## Преобразование символов

Символы не преобразуются автоматически в строки:

```js
let id = Symbol('id');

alert(id); // TypeError: Cannot convert a Symbol value to a string
alert(id.toString()); // Symbol(id) - явное преобразование
alert(id.description); // "id" - получение описания
```

## Скрытые свойства

Символы позволяют создавать «скрытые» свойства объектов:

```js
let user = {
    name: "Вася"
};

let id = Symbol('id');
user[id] = 123;

alert(user[id]); // 123
```

**Преимущества:**

- Нельзя нечаянно обратиться и перезаписать
    
- Сторонний код вряд ли увидит символ
    
- Исключаются конфликты имен

## Символы в литеральных объектах

При литеральном объявлении объекта символ нужно заключить в квадратные скобки:

```js
let id = Symbol('id');

let user = {
    name: 'Вася',
    [id]: 123 // символ как ключ
};
```

## Перебор свойств и символы

### Цикл for...in игнорирует символы:

```js
let id = Symbol('id');
let user = {
    name: "Вася",
    [id]: 123
};

for (let key in user) {
    alert(key); // только "name", символа нет
}
```

### Object.keys() также игнорирует символы:

```ts
let id = Symbol('id');
let user = {
    name: "Вася",
    [id]: 123
};

alert(Object.keys(user)); // только ["name"]
```

### Object.assign() копирует и строковые, и символьные свойства:

```js
let id = Symbol('id');
let user = { [id]: 123 };
let clone = Object.assign({}, user);

alert(clone[id]); // 123
```

## Глобальные символы

**Глобальный реестр символов** обеспечивает доступ к одному и тому же символу из разных частей приложения:

```js
// Читаем символ из глобального реестра
let id = Symbol.for('id');

// Читаем его снова (возвращается тот же символ)
let idAgain = Symbol.for('id');

alert(id === idAgain); // true
```

## Symbol.keyFor()

Для глобальных символов существует обратный метод:

```js
// Получаем символ по имени
let sym = Symbol.for('name');
let sym2 = Symbol.for('id');

// Получаем имя по символу
alert(Symbol.keyFor(sym));  // "name"
alert(Symbol.keyFor(sym2)); // "id"

// Для неглобальных символов вернет undefined
let localSym = Symbol('local');
alert(Symbol.keyFor(localSym)); // undefined
```

## Итог

- **Символы** — уникальные идентификаторы
    
- **Создание**: `Symbol(description)`
    
- **Использование**: скрытые свойства объектов
    
- **Игнорируются**: `for...in`, `Object.keys()`
    
- **Копируются**: `Object.assign()`
    
- **Глобальные символы**: `Symbol.for(key)`, `Symbol.keyFor(sym)`
    
- **Преимущество**: избежание конфликтов имен свойств

# Связанные идеи:

* [[202510031430 Типы данных в Javascript]]
---

*Что стоит развить? Какие вопросы возникли?*
