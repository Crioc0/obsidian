---
created: 2025-10-07 08:43
tags:
  - typeORM
---
# 202510070843 Конфликты при создании записи

*Ссылка на StructureNote:* [[TypeORM]]
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/learn/backend-nodejs/courses/a4214ab0-2146-4152-b90e-651bf4c7ca5e/sprints/564244/topics/104f2765-a9c9-4617-8a5e-f21b675cf9b3/lessons/5674c491-8940-41ba-bf49-d6da1cbe2337/)

В базе может быть уникальное значение, которое не может повторяться. Это может быть логин пользователя, email или уникальный идентификатор. База данных может проконтролировать уникальность записи, но вернет просто непрошедший запрос в код.

Дальше код его увидит, и выдаст ошибку со статус-кодом 500. Есть несколько способов обрботать такую ситуацию.

### Предварительная проверка

Предварительно проверить наличие записи с конфликтующими идентификаторами. Если они есть, выкинуть корректную ошибку. Требует дополнительного запроса в СУБД. А ещё может подвести нас: в случае нагруженного сервиса вы можете проверить наличие записи, увидеть, что её нет, и попытаться добавить новую. А она успеет появиться в промежутке между проверкой и добавлением.

### Поймать ошибку в `try...catch`

```ts
try {
  await userRepository.insert(users);
} catch(err){
  throw new ConflictException('username already exist');
}
```

В этом случае непонятно какая ошибка произошла. Возможно, упала Бд, а сообщение о пользователе

В этом случае нужно проверять, что именно пошло не так. Чаще всего завязываются на номер ошибки из конкретной СУБД, например так:

```ts
 // проверяем, что это именно ошибка запроса
if (error instanceof QueryFailedError) {
        // типизируем ошибку, чтобы получить её поля
        const err = error.driverError as DatabaseError;

        // сравниваем код ошибки
        if (err.code === '23505') {
          throw new ConflictException('username already exist');
        }
      }
```

### Доверить все СУБД

Можно предоставить разрешение конфликтов СУБД, и корректно обработать ответ, в котором не будет ошибки. Это можно сделать через Query Builder при помощи функции `orIgnore`:

```ts
const result = await connection.createQueryBuilder()
        .insert()
        .into(Users)
        .values(value)
        .orIgnore()
        .execute();
```

После этого можно проверить возвращаемый массив `identifiers` из результата на предмет того, добавился новый пользователь или нет. Данное решение выглядит наиболее красивым, но по-разному работает на разных СУБД.

### Связанные идеи:

* 
---

*Что стоит развить? Какие вопросы возникли?*
