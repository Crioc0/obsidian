---
created: 2025-10-07 10:22
tags:
  - typeORM
---
# 202510071023 Миграции средствами TypeORM

*Ссылка на StructureNote:* [[TypeORM]]
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/learn/backend-nodejs/courses/a4214ab0-2146-4152-b90e-651bf4c7ca5e/sprints/564244/topics/104f2765-a9c9-4617-8a5e-f21b675cf9b3/lessons/1a33d1dc-5929-45e0-98a4-01974cd651dc/)

У нас уже есть настройки базы данных в `app.module.ts`, однако CLI для TypeORM не умеет их оттуда брать. Так что нужно создать отдельный файл настроек в понятном для CLI формате. Например, так:

```ts
// ormconfig.ts
import { DataSource } from 'typeorm';

export const AppDataSource = new DataSource({
  type: 'postgres',
  host: 'localhost',
  port: 5432,
  username: 'student',
  password: 'student',
  database: 'nest_project',
  entities: ['src/**/entities/*.entity{.ts,.js}'],
  migrations: ['src/database/migrations/*.ts'],
  synchronize: false,
});
```

По умолчанию TypeORM работает только с JS-файлами миграций. Чтобы это исправить, нужно добавить несколько команд в `package.json` для удобства

```ts
"scripts": {
    "typeorm": "ts-node --files -r tsconfig-paths/register ./node_modules/typeorm/cli.js --dataSource ormconfig.ts",
    "migrate:generate": "npm run typeorm migration:generate -n",
    "migrate:create": "npm run typeorm migration:create -n",
    "migrate:up": "npm run typeorm migration:run",
    "migrate:down": "npm run typeorm migration:revert"
}
```

Первая команда будет оборачивать вызовы TypeORM, добавляя туда транспиляцию для использования TS-файлов, а также подставлять файл настроек, о котором мы говорили выше. Остальные команды оборачивают соответствующие команды TypeORM и вызывают нашу переопределённую команду `typeorm`.

Что мы здесь видим интересного:

- `migrate:generate` — создаёт новую миграцию на основании разницы текущего состояния нашей БД и описанных моделей.
- `migrate:create` — создаёт пустую миграцию, код которой можно написать руками.
- `migrate:up` — выполняет код миграции над нашей базой.
- `migrate:down` — откатывает последнюю миграцию.

Чтобы сгенерировать миграцию автоматически из ваших изменений, которые вы сделали при помощи командной строки или GUI, можно вызвать CLI TypeORM c параметром `migrate:generate`, не забыв передать имя и путь созданной миграции:

```ts
npm run migrate:generate src/database/migrations/initMigration
```

Она сравнит структуру базы с текущим описанием модели и сгенерирует нужные изменения.

В результате выполнения у вас будет создана директория для миграций согласно настройкам TypeORM (по умолчанию — `migrations`), а внутри неё файл с именем `${TIMESTAMP}-initMigration.ts`, где `${TIMESTAMP}` — это время создания файла.

### Создание миграции вручную

Чтобы создать заготовку миграции, выполните команду:

```ts
npm run migrate:create src/database/migrations/someNewMigration
```

### Структура миграции

Созданный файл, как и любая другая миграция, будет выглядеть вот так:

```ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class someNewMigrationTIMESTAMP implements MigrationInterface {
  async up(queryRunner: QueryRunner): Promise<void> {}
  async down(queryRunner: QueryRunner): Promise<void> {}
}
```

Здесь всего две функции, которые нужно заполнить:

- `up` — что мы хотим сделать в этой миграции;
- `down` — как обратить сделанное.

```ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class PostRefactoringTIMESTAMP implements MigrationInterface {
  async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE "post" RENAME COLUMN "title" TO "name"`,
    );
  }

  async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE "post" RENAME COLUMN "name" TO "title"`,
    );
  }
}
```

Теперь применение миграции переименует `title` в `name`, а её откат — переименует обратно.

### Применение и откат миграции

Чтобы применить миграцию, нужно выполнить команду:

```ts
npm run migrate:up
```

А чтобы её откатить, нужно выполнить:

```ts
npm run migrate:down
```

## Возможные ошибки, связанные с миграциями

- Необратимые миграции. Это те, для которых нельзя написать down-часть, чтобы она вернула базу в исходное состояние. Старайтесь их не делать. Всегда что-то может пойти не так, и вы сэкономите немало волос, если всегда будете иметь возможность отката. Например, вместо удаления таблицы лучше для начала переместить её или переименовать. И только когда вы убедитесь, что она на 146% нигде не используется, — удалять.
- Много операций в одной миграции. Об этом мы уже говорили выше, но лучше повторить: старайтесь делать миграции атомарными, чтобы миграция не сломалась на половине и у вас не оказалось базы в непонятном состоянии.
- Конфликты миграций. Может сложиться ситуация, когда два разных разработчика написали по миграции, которые работают с одними и теми же полями. Например, одна удаляет поле A, а другая переименовывает поле A в B. И при применении вторая не найдёт A, поскольку оно уже удалено. Такие вещи обычно решаются на уровне тестового сервера, где все миграции применяются и проверяются на продакшен-данных (или аналогичных) перед выкаткой на продакшен-сервер и базу.

### Связанные идеи:

* [[202510071022 Миграции]]
---

*Что стоит развить? Какие вопросы возникли?*
