---
repeat: spaced every 24 hours
created: 2025-10-08 14:33
tags:
  - vue
  - уровень_1
due_at: 2025-10-24T10:45:18.186+03:00
---
# 202510081433 Ссылки на элемент шаблона с помощью ref

*Ссылка на StructureNote:* [[02 Structure notes/Vue|Vue]]
*Ссылка на исходник или контекст (если есть):*

Хотя декларативная модель рендеринга Vue абстрагирует от большинства прямых операций с DOM, все же могут быть случаи, когда нужен прямой доступ к базовым элементам DOM. Для этого можно использовать специальный атрибут `ref`:

```js
<input ref="input">
```

`ref` - специальный атрибут, аналогичный атрибуту `key`, о котором говорилось в главе `v-for`. Он позволяет получить прямую ссылку на определенный элемент DOM или экземпляр дочернего компонента после его монтирования. Это может быть полезно, когда нужно, например, программно выставить фокус на поле ввода при монтировании компонента или инициализировать стороннюю библиотеку на элементе.

## Доступ к ссылкам

Чтобы получить ссылку с помощью Composition API, мы можем использовать [`useTemplateRef()`](https://ru.vuejs.org/api/composition-api-helpers.html#usetemplateref)  хэлпер. (версия 3.5+)

```js
<script setup>
import { useTemplateRef, onMounted } from 'vue'

// первый аргумент должен совпадать с значением ref в шаблоне
const input = useTemplateRef('my-input')

onMounted(() => {
  input.value.focus()
})
</script>

<template>
  <input ref="my-input" />
</template>
```

До версии 3.5

```js
<script setup>
import { ref, onMounted } from 'vue'

// объявляем ref-ссылку на элемент
// имя должно совпадать со значением ref в шаблоне
const input = ref(null)

onMounted(() => {
  input.value.focus()
})
</script>

<template>
  <input ref="input" />
</template>
```

Обратите внимание, что вы можете получить доступ к ссылке только **после того, как компонент был смонтирован**. Если вы попытаетесь получить доступ к `input` в шаблоне, при первом рендеринге она будет равна `null`. Это происходит потому, что элемент не существует до завершения первого рендеринга!

Если попытаться следить за изменениями ссылки на элемент шаблона, обязательно учитывать случай, когда ссылка имеет значение `null`:

```js
watchEffect(() => {
  if (input.value) {
    input.value.focus()
  } else {
    // еще не смонтирован, или элемент был демонтирован (например: v-if)
  }
})
```

## Ref в компоненте

`ref` можно также использовать для дочернего компонента. В этом случае ссылка будет принадлежать экземпляру компонента: (версия 3.5+)

```js
<script setup>
import { useTemplateRef, onMounted } from 'vue'
import Child from './Child.vue'

const childRef = useTemplateRef('child')

onMounted(() => {
  // childRef.value будет содержать объект <Child />
})
</script>

<template>
  <Child ref="child" />
</template>
```

До версии 3.5

```js
<script setup>
import { ref, onMounted } from 'vue'
import Child from './Child.vue'

const child = ref(null)

onMounted(() => {
  // child.value будет содержать экземпляр <Child />
})
</script>

<template>
  <Child ref="child" />
</template>
```

Если дочерний компонент использует Options API или не использует `<script setup>`, то экземпляр ссылки будет идентичен экземпляру дочернего компонента `this`, что означает, что родительский компонент будет иметь полный доступ к каждому свойству и методу дочернего компонента. Это позволяет легко создавать тесно связанные детали реализации между родительским и дочерним компонентами, поэтому ссылки на компонент следует использовать только в случае крайней необходимости - в большинстве случаев необходимо попытаться реализовать взаимодействие родителя и ребенка, используя стандартные интерфейсы props и emit.

# Связанные идеи:

* 

---

*Что стоит развить? Какие вопросы возникли?*
