---
created: 2025-10-07 10:16
tags:
  - typeORM
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510071016 Пагинация TypeORM

*Ссылка на StructureNote:* [[TypeORM]]
*Ссылка на исходник или контекст (если есть):*

В реальных приложениях мы часто не можем вернуть все данные разом. Их может быть слишком много, и тут без разбивки ответа на страницы (пагинации) не обойтись. И делать её нужно именно на сервере, а не на клиенте.

В этом поможет функция `findAndCount`, а также аргументы `take` и `skip`. Аргумент `take` говорит, сколько нам нужно взять записей, а `skip` — с какой записи нужно начать. Сама `findAndCount` работает довольно хитро. «Под капотом» она делает два запроса: один на то, чтобы посчитать общее количество результатов без учёта `take` и `skip`, а второй — чтобы выбрать данные с учётом `take` и `skip`. Таким образом функция сервиса, который получает нужную страницу записей, может выглядеть так:

```ts
// это часть некоего сервиса для работы с данными пользователей
const recordsOnPage = 50; // указываем количество объектов на страницу

async getPaginated(
    page: number,
  ): Promise<User> {
    const take = recordsOnPage;
    const skip = recordsOnPage*page;
    // формируем настройки запроса
    const options: FindManyOptions<User> = {
      order: { id: 'ASC' },
      take,
      skip,
    };
    // запрашиваем данные через репозиторий
    const [data, total] = await this.repo.findAndCount(options);
    return {
      data,
      total,
    };
  }
```

Обратите внимание, что для пагинации обязательно стоит указывать поле для сортировки результатов при помощи параметра `order`. Иначе они будут сортироваться неведомым образом, зависящим от конкретной СУБД, и выдавать разные результаты.

### Связанные идеи:

* 

---

*Что стоит развить? Какие вопросы возникли?*
