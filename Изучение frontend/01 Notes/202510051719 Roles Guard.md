---
created: 2025-10-05 17:19
tags:
  - nestjs
---
# 202510051719
*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):* 

Контекст выполнения хорош тем, что обеспечивает доступ не только к запросу, но и к данным о текущем процессе обработки запроса. Это позволяет нам устанавливать метаданные в контекст выполнения и уже на их основе принимать решение в гарде.

Для начала объявим `RolesGuard`, пусть он пока пропускает все запросы.
```ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean {
    return true;
  }
}
```
Теперь нужно подключить гарду к контроллеру и установить на методы контроллера метаданные. Их вы можете добавить с помощью декоратора `@SetMetadata`:
```ts
import { Controller, Post, UseGuards, SetMetadata } from '@nestjs/common';
import { RolesGuard } from '../guards/roles.guard';

@Controller('posts')
@UseGuards(RolesGuard)
export class PostsController {
  @Post()
  // посты могут создавать только пользователи с ролью admin
  @SetMetadata('roles', ['admin']) 
  create() {
    return 'This action will create a post';
  }
}
```

Чтобы было удобнее устанавливать метаданные, вы можете создать собственный декоратор:
```ts
import { SetMetadata } from '@nestjs/common';

export const Roles = (...roles: string[]) => SetMetadata('roles', roles);
```
```ts
@Post()
@Roles(['admin']) // посты могут создавать только пользователи с ролью admin
create() {
  return 'This action will create a post';
}
```
Осталось на основе метаданных контекста выполнения решить, передавать запрос в контроллер или нет. Чтобы получить метаданные внутри гарды, понадобится класс `Reflector` из пакета `@nestjs/core`. А чтобы получить текущий обработчик (метод контроллера), воспользуйтесь методом контекста `getHandler`:
### Связанные идеи:
* 
---

*Что стоит развить? Какие вопросы возникли?*