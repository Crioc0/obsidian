---
created: 2025-10-05 17:19
tags:
  - nestjs
---
# 202510051719 Roles Guard

*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):* 

Контекст выполнения хорош тем, что обеспечивает доступ не только к запросу, но и к данным о текущем процессе обработки запроса. Это позволяет нам устанавливать метаданные в контекст выполнения и уже на их основе принимать решение в гарде.

Для начала объявим `RolesGuard`, пусть он пока пропускает все запросы.

```ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean {
    return true;
  }
}
```

Теперь нужно подключить гарду к контроллеру и установить на методы контроллера метаданные. Их вы можете добавить с помощью декоратора `@SetMetadata`:

```ts
import { Controller, Post, UseGuards, SetMetadata } from '@nestjs/common';
import { RolesGuard } from '../guards/roles.guard';

@Controller('posts')
@UseGuards(RolesGuard)
export class PostsController {
  @Post()
  // посты могут создавать только пользователи с ролью admin
  @SetMetadata('roles', ['admin']) 
  create() {
    return 'This action will create a post';
  }
}
```

Чтобы было удобнее устанавливать метаданные, вы можете создать собственный декоратор:

```ts
import { SetMetadata } from '@nestjs/common';

export const Roles = (...roles: string[]) => SetMetadata('roles', roles);
```

```ts
@Post()
@Roles(['admin']) // посты могут создавать только пользователи с ролью admin
create() {
  return 'This action will create a post';
}
```

Осталось на основе метаданных контекста выполнения решить, передавать запрос в контроллер или нет. Чтобы получить метаданные внутри гарды, понадобится класс `Reflector` из пакета `@nestjs/core`. А чтобы получить текущий обработчик (метод контроллера), воспользуйтесь методом контекста `getHandler`:

```ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get<string[]>('roles', context.getHandler());

    // если у обработчика нет данных о ролях, пропускаем запрос в контроллер
    if (!roles) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    // если у пользователя есть хотя бы одна нужная роль, запрос пройдёт дальше
    return roles.some(role => user.roles.includes(role));
  }
}
```

Объект с данными пользователя `request.user` устанавливается при авторизации пользователя.

С помощью гард мы можем ограничивать доступ пользователей к ресурсам. Условием для получения доступа могут быть не только роли, но и любые другие метаданные или параметры запроса. Например, мы можем ограничивать доступ ко всем роутам, для которых установим декоратор `Deprecated`:

```ts
import { SetMetadata } from '@nestjs/common';

export const Deprecated = () => SetMetadata('deprecated', true);
```

### Связанные идеи:

* [[202510051709 Guards NestJS]]
---

*Что стоит развить? Какие вопросы возникли?*
