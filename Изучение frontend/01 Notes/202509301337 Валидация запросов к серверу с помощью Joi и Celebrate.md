---
created: 2025-09-30 13:37
tags:
  -
---
# 202509301337
*Ссылка на StructureNote:* [[02 Structure notes/NodeJS|NodeJS]] [[02 Structure notes/Express|Express]]
*Ссылка на исходник или контекст (если есть):* [Документация JOI](https://joi.dev/api/?v=17.13.3) 

Чтобы валидация данных на уровне схемы сработала, приложение должно обработать код и выполнить код контроллера. 
Можно провалидировать данные до того, как данные попадут в контроллер: проверить тело запроса, его заголовки,  только потом пускать их дальше

Существует множество инструментов и библиотек для валидации данных в Node.js, такие как `ajv`, `fastest-validator` и `celebrate`. Мы остановимся на последнем, и вот почему: `celebrate` легко интегрируется в проект на Express и «под капотом» использует проверенную временем библиотеку валидации `joi`.

Чтобы подключить валидацию Joi в качестве мидлвара, мы будем использовать библиотеку celebrate. Перед использованием её нужно установить в проект, после чего импортировать и подключить как мидлвар к роуту
```ts
const { celebrate, Joi } = require('celebrate');

router.post('/posts', celebrate({
  body: Joi.object().keys({
    title: Joi.string().required().min(2).max(30),
    text: Joi.string().required().min(2),
  }),
}), createPost);
```
Кроме тела запроса, celebrate позволяет валидировать заголовки, параметры или `req.query`:
```ts
const { celebrate, Joi } = require('celebrate');

router.delete('/:postId', celebrate({
  // валидируем параметры
  params: Joi.object().keys({
    postId: Joi.string().alphanum().length(24),
  }),
  headers: Joi.object().keys({
    // валидируем заголовки
  }),
  query: Joi.object().keys({
    // валидируем query
  }),
}), deletePost);
```
По умолчанию Joi не допускает полей, которые не перечислены в объекте валидации. Чтобы изменить это поведение, нужно после вызова метода `keys` вызвать метод `unknown` с аргументом `true`:
### Ошибки

Если запрос не проходит описанную валидацию, celebrate передаст его дальше, но не в контроллер, а в обработчик ошибки.

Можно описать логику обработки таких ошибок самостоятельно при помощи соответствующей проверки и метода **`isCelebrateError(err)`**, но есть возможность подключить готовый мидлвар `errors`.
```ts
// app.js

const { errors } = require('celebrate');

// ...

// обработчики ошибок
app.use(errors()); // обработчик ошибок celebrate

// наш централизованный обработчик
app.use((err, req, res, next) => {
  // ...
});
```
Мидлвар `errors()` будет обрабатывать только ошибки, которые сгенерировал celebrate. Все остальные ошибки он передаст дальше, где их перехватит централизованный обработчик.

### Связанные идеи:
* [[202509260815 Схемы mongoose]]
---

*Что стоит развить? Какие вопросы возникли?*