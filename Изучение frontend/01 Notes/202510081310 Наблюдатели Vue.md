---
created: 2025-10-08 13:10
tags:
  - vue
---
# 202510081310
*Ссылка на StructureNote:* [[02 Structure notes/Vue|Vue]]
*Ссылка на исходник или контекст (если есть):* 

Бывают случаи, когда нам необходимо выполнить "побочные эффекты" в ответ на изменение состояния. Например, мутировать DOM или изменить другой фрагмент состояния на основе результата асинхронной операции.

С Composition API мы можем использовать [функцию](https://ru.vuejs.org/api/reactivity-core.html#watch) `watch` для запуска обратного вызова всякий раз, когда изменяется часть реактивного состояния:
```js
<script setup>
import { ref, watch } from 'vue'

const question = ref('')
const answer = ref('Вопросы обычно заканчиваются вопросительным знаком. ;-)')
const loading = ref(false)

// watch работает прямо в ref
watch(question, async (newQuestion, oldQuestion) => {
  if (newQuestion.includes('?')) {
    loading.value = true
    answer.value = 'Думаю...'
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Ошибка! Нет доступа к API. ' + error
    } finally {
      loading.value = false
    }
  }
})
</script>

<template>
  <p>
    Ask a yes/no question:
    <input v-model="question" :disabled="loading" />
  </p>
  <p>{{ answer }}</p>
</template>
```
### Типы источников watch
Первым аргументом `watch` могут быть различные типы реактивных "источников": это может быть ref (включая вычисляемые refs), реактивный объект, [геттер-функция](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description) или массив из нескольких источников:
```js
const x = ref(0)
const y = ref(0)

// одиночный ref
watch(x, (newX) => {
  console.log(`x is ${newX}`)
})

// геттер
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`сумма x + y равна: ${sum}`)
  }
)

// массив из нескольких источников
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x равен ${newX} и y равен ${newY}`)
})
```
Обратите внимание, что вы не можете наблюдать за свойством реактивного объекта таким образом:
```js
const obj = reactive({ count: 0 })

// это не сработает, потому что мы передаем число в watch()
watch(obj.count, (count) => {
  console.log(`Счетчик равен: ${count}`)
})
```
Вместо этого используйте геттер:
```js
// вместо этого используйте геттер:
watch(
  () => obj.count,
  (count) => {
    console.log(`Счетчик равен: ${count}`)
  }
)
```

# Связанные идеи:
* [[202510081313 Глубокие наблюдатели]]
* [[202510081315 Нетерпеливые и единичные наблюдатели]]
* [[202510081317 WatchEffect]]
---

*Что стоит развить? Какие вопросы возникли?*