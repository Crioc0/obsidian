---
created: 2025-10-05 17:09
tags:
  - nestjs
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510051709  Guards NestJS

*Ссылка на StructureNote:* [[Nest.js]]
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/trainer/backend-nodejs/lesson/4a7f433e-2cdd-49d1-bbf2-b02c818cf2b1/task/0c27cf46-9eba-4d25-87f9-06e81141af66/)

Для того, чтобы разграничить доступ к ресурсу, в Nest.js существует абстрация "защитник"(или guard). Это специальный класс, единственное назначение которого - определять, должен ли быть обработан запрос или нет. Guard отмечается декоратором `@Injectable` и должен имплементировать интерфейс `CanActivate`. Для использования достаточно добавить к контроллеру декоратор `@UseGuards`

```ts
import { Controller, UseGuards } from '@nestjs/common';
import { BlockGuard } from '../guards/block.guard';

@Controller('/blocked')
@UseGuards(BlockGuard)
export class BlockedController {}
```

В метод `canActivate` первым аргументом приходит контекст выполнения (execution context). С помощью контекста мы можем получить доступ к объекту запроса:

```ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';

@Injectable()
export class MyGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const token = request.header('Authorization');
    // isAuthorize - условный метод (реализация опущена)
    // он проверяет корректность токена и возвращает true/false
    return isAuthorizaed(token);
  }
}
```

### Связанные идеи:

* 
---

*Что стоит развить? Какие вопросы возникли?*
