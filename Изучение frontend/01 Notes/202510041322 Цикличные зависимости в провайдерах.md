---
created: 2025-10-04 13:22
tags:
  - nestjs
repeat: spaced every day
due_at: 2025-10-24T06:00:00.000+03:00
---
# 202510041322 Цикличные зависимости в провайдерах

*Ссылка на StructureNote:*
*Ссылка на исходник или контекст (если есть):* [ЯПрактикум](https://practicum.yandex.ru/learn/backend-nodejs/courses/a4214ab0-2146-4152-b90e-651bf4c7ca5e/sprints/564244/topics/1df920a3-5c6a-4fcd-884c-0f66136c2b56/lessons/c7fc68f1-9b64-415b-aec7-f932fe458400/)

При разработке на JavaScript цикличные зависимости получаются, когда модуль A использует модуль B, а модуль B использует модуль A:

```ts
// A.ts
import * as moduleB from './B';

export const run = () => {
  moduleB.run();
}

// B.ts
import * as moduleA from './A';

export const run = () => {
  moduleA.run();
}

run();
```

При импорте модулей Node.js считает, что модуль не определён, пока весь файл с кодом не будет прочитан. Поэтому, если файл `A.ts` из примера будет исполнен, мы получим ошибку `ReferenceError: run is not defined`.

То же самое может произойти и с провайдерами в Nest.js:

```ts
// providerA.ts
@Injectable()
export class ProviderA {
  constructor(private providerB: ProviderB) {}
}

// providerB.ts
@Injectable()
export class ProviderB {
  constructor(private providerA: ProviderA) {}
}
```

Обычно Nest.js будет инициализировать провайдеры при инициализации класса, в который они внедряются. Но из-за цикличной зависимости не все метаданные провайдера `ProviderB` будут доступны во время инициализации `ProviderA` — возникнет ошибка.

Nest.js умеет самостоятельно находить цикличные зависимости и сообщать об этом в терминал.

Чтобы разрешить цикличные зависимости, Nest.js предоставляет функцию `forwardRef`. Благодаря `forwardRef` провайдеры `ProviderA` и `ProviderB` не будут инициализированы, пока все необходимые метаданные не будут доступны, а значит, ошибки не возникнет.

```ts
// providerA.ts
@Injectable()
export class ProviderA {
  constructor(
    @Inject(forwardRef(() => ProviderB))
    private providerB: ProviderB
  ) {}
}

// providerB.ts
@Injectable()
export class ProviderB {
  constructor(
    @Inject(forwardRef(() => ProviderA))
    private providerA: ProviderA
  ) {}
}
```

Цикличные зависимости повышают связанность кода и могут свидетельствовать о нарушении принципа разделения интерфейсов, а значит, ухудшают поддерживаемость кода в долгосрочной перспективе. Поэтому старайтесь избегать цикличных зависимостей везде, где возможно.

### Связанные идеи:

* [[202510022039 Провайдеры, или сервисы]]

---

*Что стоит развить? Какие вопросы возникли?*
