2025 07 0518 41
Tags: #vue 
###### Links: 
1) 
# Заметка
Реализация виртуального DOM в React и большинстве других реализаций виртуального DOM является чисто исполнительной: алгоритм согласования не может делать никаких предположений о входящем виртуальном DOM-дереве, поэтому для обеспечения корректности ему приходится полностью обходить это дерево и дифферинцировать входные параметры каждого vnode. Кроме того, даже если часть дерева никогда не изменяется, при каждом повторном рендеринге для нее всегда создаются новые vnode, что приводит к излишней нагрузке на память.
Во Vue фреймворк контролирует и компилятор, и время выполнения. Это позволяет нам реализовать множество оптимизаций во время компиляции, которыми может воспользоваться только тесно связанный рендерер. Компилятор может статически анализировать шаблон и оставлять подсказки в сгенерированном коде, чтобы время выполнения могло использовать короткие пути, когда это возможно. В то же время мы сохраняем возможность для пользователя опускаться на уровень функций рендеринга для более прямого управления в крайних случаях. Мы называем этот гибридный подход **виртуальный DOM на основе данных компилятора**.

Основные оптимизации
### Cache Static[​](https://ru.vuejs.org/guide/extras/rendering-mechanism.html#cache-static)

Довольно часто в шаблоне встречаются части, не содержащие динамических привязок:

template

```
<div>
  <div>foo</div> <!-- cached -->
  <div>bar</div> <!-- cached -->
  <div>{{ dynamic }}</div>
</div>
```
Рендеринг div с foo и bar статичен-он не требует сравнения со старым vnode при каждом ререндере. Поэтому при первом рендере он их создает и кэширует, и при каждом последующем ререндере использует те же vnodes. Процесс реерендера так же способен полностью пропускать сравнение, когда он поймет, что новый и стррый vnode полностью идентичны.
Также, если будет достаточное количество последовательных статических элементов, они будут соединены в один статический vnode, который содержит чистый HTML код всех этих vnodes. Статические vnodes монтируются напрямую с помощью innerHTML.
### Флаги патчей[​](https://ru.vuejs.org/guide/extras/rendering-mechanism.html#patch-flags)

Для отдельного элемента с динамическими связями мы также можем вывести много информации из него во время компиляции:
```js
<!-- только привязка к классам -->
<div :class="{ active }"></div>

<!-- только привязки к id и value -->
<input :id="id" :value="value">

<!-- только для текста -->
<div>{{ dynamic }}</div>
```
При генерации кода функции рендеринга для этих элементов Vue кодирует тип обновления, который требуется каждому из них, непосредственно в вызове создания vnode:
```js
createElementVNode("div", {
  class: _normalizeClass({ active: _ctx.active })
}, null, 2 /* КЛАСС */)
```
Последний аргумент, `2`, является [флагом патча](https://github.com/vuejs/core/blob/main/packages/shared/src/patchFlags.ts). Элемент может иметь несколько флагов патча, которые будут объединены в одно число. Рендерер во время выполнения может проверить флаги с помощью [побитовых операций](https://en.wikipedia.org/wiki/Bitwise_operation), чтобы определить, нужно ли ему выполнять определенную работу
```js
if (vnode.patchFlag & PatchFlags.CLASS /* 2 */) {
  // обновление класса элемента
}
```
Vue также кодирует тип дочерних узлов. Например, шаблон, имеющий несколько корневых узлов, представляется в виде фрагмента. В большинстве случаев мы точно знаем, что порядок этих корневых узлов никогда не изменится, поэтому эта информация также может быть предоставлена среде выполнения в качестве флага патча:
```js
export function render() {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    /* дочерние элементы */
  ], 64 /* СТАБИЛЬНЫЙ_ФРАГМЕНТ */))
}
```
Таким образом, время выполнения может полностью пропустить согласование дочерних фрагментов для корневого фрагмента.
### Сплющивание дерева
Если еще раз взглянуть на сгенерированный код из предыдущего примера, то можно заметить, что корень возвращаемого виртуального DOM-дерева создается с помощью специального вызова `createElementBlock()`:
```js
export function render() {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    /* дочерние элементы */
  ], 64 /* СТАБИЛЬНЫЙ_ФРАГМЕНТ */))
}
```
Концептуально "блок" - это часть шаблона, имеющая стабильную внутреннюю структуру. В данном случае весь шаблон имеет один блок, поскольку не содержит структурных директив типа `v-if` и `v-for`.
Каждый блок отслеживает все узлы-потомки (а не только прямые дочерние узлы), имеющие флаги патча. Например:
```js
<div> <!-- корневой блок -->
  <div>...</div>         <!-- не отслеживается -->
  <div :id="id"></div>   <!-- отслеживается -->
  <div>                  <!-- не отслеживается -->
    <div>{{ bar }}</div> <!-- отслеживается -->
  </div>
</div>
```
В результате получается сглаженный массив, содержащий только динамические узлы-потомки:
```js
div (корневой блок)
- div с привязкой :id
- div с привязкой {{ bar }}
```
При повторном рендеринге компонента вместо полного дерева ему приходится обходить только сплющенное дерево. Это называется **Сплющивание дерева**, и значительно сокращает количество узлов, которые необходимо обходить при виртуальном выравнивании DOM. При этом статические части шаблона фактически пропускаются.
Директивы `v-if` и `v-for` создают новые узлы блока:
```js
<div> <!-- корневой блок -->
  <div>
    <div v-if> <!-- если блок -->
      ...
    </div>
  </div>
</div>
```