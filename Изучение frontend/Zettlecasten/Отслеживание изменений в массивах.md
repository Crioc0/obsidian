2025 06 2817 05
Tags: #vue 
###### Links: 
1) [[Отрисовка списков]] 
# Заметка
Vue способен определять, когда вызываются методы мутации реактивного массива, и запускать необходимые обновления. К таким мутирующим методам относятся:

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

### Методы изменения с заменой массива
Методы, мутирующие массив, как следует из названия, будут изменять исходный массив, на котором они вызваны. Но есть и другие, например `filter()`, `concat()` и `slice()`, которые не мутируют исходный массив, а **всегда возвращают новый массив**. При их использовании можно просто заменять старый массив на новый:
```js
// `items` это ref-ссылка с массивом в значении
items.value = items.value.filter((item) => item.message.match(/Foo/))
```
## Отображение отфильтрованных/отсортированных результатов
Иногда может потребоваться отображать отфильтрованную или отсортированную версию массива, сохранив оригинальные данные. В таком случае можно создать вычисляемое свойство, которое будет возвращать отфильтрованный или отсортированный массив.
```js
const numbers = ref([1, 2, 3, 4, 5])

const evenNumbers = computed(() => {
  return numbers.value.filter((n) => n % 2 === 0)
})
```

```js
<li v-for="n in evenNumbers">{{ n }}</li>
```
В ситуациях, когда вычисляемые свойства нельзя применить(например, во вложенных циклах v-for), можно использовать метод:
```js
const sets = ref([
  [1, 2, 3, 4, 5],
  [6, 7, 8, 9, 10]
])

function even(numbers) {
  return numbers.filter((number) => number % 2 === 0)
}

<ul v-for="numbers in sets">
  <li v-for="n in even(numbers)">{{ n }}</li>
</ul>
```

При использовании reverse и sort в вычисляемых свойствах нужно быть внимательным, так как они изменяют исходный массив, а этого следует избегать в геттерах. Поэтому при использовании нужно создать копию исходного массива
```js
- return numbers.reverse()
+ return [...numbers].reverse()
```
