2025 07 0309 28
Tags: #vue
###### Links: 
1) 
# Заметка
Технически каждый экземпляр компонента Vue уже "управляет" своим реактивным состоянием. Возьмём для примера простой компонент счетчика:
```js
<script setup>
import { ref } from 'vue'

// состояние
const count = ref(0)

// действия
function increment() {
  count.value++
}
</script>

<!-- представление -->
<template>{{ count }}</template>
```
Это самостоятельный блок, состоящий из следующих частей:

- **Состояние** - источник данных, который управляет нашим приложением;
- **Представление** - декларативное отображение **состояния**;
- **Действия** - возможные способы изменения состояния в ответ на пользовательский ввод из **представления**.
Это простое представление концепции "одностороннего потока данных"
Однако эта простота начинает нарушаться, когда у нас есть **несколько компонентов, имеющих общее состояние**:

1. Несколько представлений могут зависеть от одного и того же фрагмента состояния.
2. Действиям из разных представлений может потребоваться мутировать один и тот же фрагмент состояния.
В первом случае возможным обходным путем является "поднятие" общего состояния до общего компонента-предка, а затем передача его вниз в виде входных параметров. В случае глубокой иерархии приводит к prop drilling

Во втором случае мы часто прибегаем к таким решениям, как обращение к прямым родительским и дочерним экземплярам через ссылки на элементы шаблона или попытка мутировать и синхронизировать несколько копий состояния через генерируемые события. Оба эти паттерна являются хрупкими и быстро приводят к сложно поддерживаемому коду.