2025 07 0409 56
Tags: #vue #typescript 
###### Links: 
1) 
# Заметка
## Типизация `ref()`
Ссылки выводят тип из начального значения:
```js
import { ref } from 'vue'

// выводимый тип: Ref<number>
const year = ref(2020)

// => TS Error: Тип 'string' не может быть присвоен типу 'number'.
year.value = '2020'
```
Иногда возникает необходимость указать сложные типы для внутреннего значения ссылки. Для этого можно использовать тип `Ref`:
```js
import { ref } from 'vue'
import type { Ref } from 'vue'

const year: Ref<string | number> = ref('2020')

year.value = 2020 // ок!
```
Или, передав общий аргумент при вызове `ref()` переопределить вывод по умолчанию:
```js
// итоговый тип: Ref<string | number>
const year = ref<string | number>('2020')

year.value = 2020 // ок!
```
Если указать аргумент типа generic, но опустить начальное значение, то результирующим типом будет тип union, включающий `undefined`:
```js
// предполагаемый тип: Ref<number | undefined>
const n = ref<number>()
```
## Типизация `reactive()`
`reactive()` также неявно выводит тип из своего аргумента:
```js
import { reactive } from 'vue'

// предполагаемый тип: { title: string }
const book = reactive({ title: 'Руководство по Vue 3' })
```
Чтобы явно ввести свойство `reactive`, мы можем использовать интерфейсы:
```js
import { reactive } from 'vue'

interface Book {
  title: string
  year?: number
}

const book: Book = reactive({ title: 'Руководство по Vue 3' })
```