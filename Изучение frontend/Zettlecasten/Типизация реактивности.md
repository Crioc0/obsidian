2025 07 0409 56
Tags: #vue #typescript 
###### Links: 
1) 
# Заметка
## Типизация `ref()`
Ссылки выводят тип из начального значения:
```js
import { ref } from 'vue'

// выводимый тип: Ref<number>
const year = ref(2020)

// => TS Error: Тип 'string' не может быть присвоен типу 'number'.
year.value = '2020'
```
Иногда возникает необходимость указать сложные типы для внутреннего значения ссылки. Для этого можно использовать тип `Ref`:
```js
import { ref } from 'vue'
import type { Ref } from 'vue'

const year: Ref<string | number> = ref('2020')

year.value = 2020 // ок!
```
Или, передав общий аргумент при вызове `ref()` переопределить вывод по умолчанию:
```js
// итоговый тип: Ref<string | number>
const year = ref<string | number>('2020')

year.value = 2020 // ок!
```
Если указать аргумент типа generic, но опустить начальное значение, то результирующим типом будет тип union, включающий `undefined`:
```js
// предполагаемый тип: Ref<number | undefined>
const n = ref<number>()
```
## Типизация `reactive()`
`reactive()` также неявно выводит тип из своего аргумента:
```js
import { reactive } from 'vue'

// предполагаемый тип: { title: string }
const book = reactive({ title: 'Руководство по Vue 3' })
```
Чтобы явно ввести свойство `reactive`, мы можем использовать интерфейсы:
```js
import { reactive } from 'vue'

interface Book {
  title: string
  year?: number
}

const book: Book = reactive({ title: 'Руководство по Vue 3' })
```
## Типизация `computed()`[​](https://ru.vuejs.org/guide/typescript/composition-api.html#typing-computed)

`computed()` определяет его тип на основе возвращаемого значения геттера:
```js
import { ref, computed } from 'vue'

const count = ref(0)

// предполагаемый тип: ComputedRef<number>
const double = computed(() => count.value * 2)

// => TS Error: Свойство 'split' не существует для типа 'number'
const result = double.value.split('')
```
Вы также можете указать явный тип через аргумент дженерика:
```js
const double = computed<number>(() => {
  // ошибка типа, если это не возвращает число
})
```
