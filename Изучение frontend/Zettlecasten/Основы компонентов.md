2025 06 2818 28
Tags: #vue 
###### Links: 

1) [[Передача входных параметров в компоненты]]
2) [[События в Vue]]
3) [[Встроенные компоненты Vue]]


## Прослушивание событий
По мере разработки нашего компонента `<BlogPost>`, некоторые функции могут потребовать обратной связи с родительским компонентом. Например, мы можем решить включить функцию доступности для увеличения текста записей блога, оставляя при этом размер остальной части страницы по умолчанию.
В родителе мы можем включить эту функцию, добавив свойство `postFontSize`:
```js
const posts = ref([
  /* ... */
])

const postFontSize = ref(1)
```
Которая может использоваться в шаблоне для управления размером шрифта всех записей блога:`
```js
<div :style="{ fontSize: postFontSize + 'em' }">
  <BlogPost
    v-for="post in posts"
    :key="post.id"
    :title="post.title"
   />
</div>
```
Теперь давайте добавим кнопку в шаблон компонента `<BlogPost>`:
```js
<!-- BlogPost.vue, не добавлен <script> -->
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button>Увеличить размер текста</button>
  </div>
</template>
```
При нажатии на кнопку нужно сообщить родительскому компоненту, чтобы увеличил размер текста для всех записей блога. Для решения этой проблемы, экземпляры компонента предоставляют собственную систему событий. Родительский компонент может прослушивать любые события на экземпляре дочернего компонента с помощью `v-on` или `@`, аналогично отслеживанию нативных событий DOM:
```js
<BlogPost
  ...
  @enlarge-text="postFontSize += 0.1"
 />
```
Тогда дочерний компонент может сгенерировать событие с помощью встроенного [метода `$emit`](https://ru.vuejs.org/api/component-instance.html#emit), передавая ему имя события:
```js
<!-- BlogPost.vue, не добавлен <script> -->
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button @click="$emit('enlarge-text')">Увеличить размер текста</button>
  </div>
</template>
```
Благодаря прослушиванию события `@enlarge-text="postFontSize += 0.1"`, родительский компонент отследит событие и обновится со значением `postFontSize`.

Все генерируемые компонентом события можно перечислить в [`defineEmits`](https://ru.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits):
Это позволит проверять все события, которые генерирует компонент, и опционально [валидировать их](https://ru.vuejs.org/guide/components/events.html#events-validation). Это также позволяет Vue избежать неявного применения их в качестве нативных слушателей к корневому элементу дочернего компонента.

Как и `defineProps`, `defineEmits` используется только в `<script setup>` и не требует импорта. defineEmits возвращает функцию `emit`, которая эквивалентна методу `$emit`. Её можно использовать для генерации событий в разделе компонента `<script setup>`, где `$emit` недоступен напрямую:
```js
<script setup>
const emit = defineEmits(['enlarge-text'])

emit('enlarge-text')
</script>
```
Если вы не используете `<script setup>`, вы можете объявить эмитируемые события с помощью опции `emits`. Вы можете получить доступ к функции `emit` как к свойству контекста настройки (передается в `setup()` в качестве второго аргумента):
```js
export default {
  emits: ['enlarge-text'],
  setup(props, ctx) {
    ctx.emit('enlarge-text')
  }
}
```
## Распределение контента слотами
Как и в случае с обычными HTML-элементами, часто бывает полезным иметь возможность передавать компоненту содержимое, например таким образом:
```js
<AlertBox>
  Произошло что-то плохое.
</AlertBox>
```
Такого можно добиться при помощи пользовательского элемента `<slot>` у Vue:
```js
<!-- AlertBox.vue -->
<template>
  <div class="alert-box">
    <strong>Эта ошибка для демонстрационных целей</strong>
    <slot />
  </div>
</template>

<style scoped>
.alert-box {
  /* ... */
}
</style>
```
Как можно увидеть выше, `<slot>` будет использоваться в качестве места, куда потребуется подставлять контент — и это всё. Готово!
## Динамические компоненты
Иногда бывает полезным динамически переключаться между компонентами, как например в интерфейсе с вкладками. Это возможно сделать с помощью элемента `<component>` со специальным атрибутом `is`:
```js
<!-- Компонент будет меняться при изменении currentTab -->
<component :is="tabs[currentTab]"></component>
```
В примере выше значением `:is` может быть:

- имя зарегистрированного компонента, или
- объект с настройками компонента

Можно также использовать атрибут `is` и для создания обычных HTML-элементов.

При переключении между несколькими компонентами с помощью `<component :is="...">`, компонент будет размонтирован при отключении от него. Мы можем заставить неактивные компоненты оставаться "живыми" с помощью встроенного [компонента `<KeepAlive>`](https://ru.vuejs.org/guide/built-ins/keep-alive.html).