2025 06 2818 28
Tags: #vue 
###### Links: 
1) [[Регистрация компонентов]]
2) [[Передача входных параметров в компоненты]]
3) [[События в Vue]]

# Заметка
Компоненты позволяют разбить пользовательский интерфейс на независимые и многократно используемые части и думать о каждой части по отдельности. Обычно приложение организовано в виде дерева вложенных друг в друга компонентов
## Определение компонента
При использовании шага сборки мы обычно определяем каждый компонент Vue в отдельном файле с расширением `.vue` - это называется [однофайловый компонент](https://ru.vuejs.org/guide/scaling-up/sfc.html) (по англ. Single-File Component или, сокращённо, SFC):
```js
<script setup>
import { ref } from 'vue'

const count = ref(0)
</script>

<template>
  <button @click="count++">Вы нажали на меня {{ count }} раз.</button>
</template>
```
Если не использовать шаг сборки, компонент Vue можно определить как обычный объект JavaScript, содержащий специфические для Vue опции:
```js
import { ref } from 'vue'

export default {
  setup() {
    const count = ref(0)
    return { count }
  },
  template: `
    <button @click="count++">
      Вы нажали на меня {{ count }} раз.
    </button>`
  // Can also target an in-DOM template:
  // template: '#my-template-element'
}
```
## Использование компонента
Чтобы использовать дочерний компонент, мы должны импортировать его в родительский компонент. Если мы разместили наш компонент счётчика в файле под названием `ButtonCounter.vue`, то компонент будет экспортирован в файл по умолчанию:
```js
<script setup>
import ButtonCounter from './ButtonCounter.vue'
</script>

<template>
  <h1>Здесь дочерний компонент!</h1>
  <ButtonCounter />
</template>
```
С помощью `<script setup>`, импортированные компоненты автоматически становятся доступными для шаблона.

Также можно глобально зарегистрировать компонент, сделав его доступным для всех компонентов данного приложения без необходимости его импорта.

В SFC рекомендуется использовать имена тегов для дочерних компонентов в регистре `PascalCase`, чтобы отличить их от собственных элементов HTML. Хотя имена тегов HTML не чувствительны к регистру, Vue SFC - это скомпилированный формат, поэтому мы можем использовать в нем имена тегов с учетом регистра. Мы также можем использовать `/>` для закрытия тега.

Если вы создаете свои шаблоны непосредственно в DOM (например, как содержимое собственного элемента `<template>`), то шаблон будет подчиняться собственному поведению браузера при разборе HTML. В таких случаях необходимо использовать регистр `kebab-case` и явные закрывающие теги для компонентов:
```js
<!-- если этот шаблон записан в DOM -->
<button-counter></button-counter>
<button-counter></button-counter>
<button-counter></button-counter>
```
## Передача входных параметров
Входные параметры — это настраиваемые атрибуты, которые вы можете зарегистрировать в компоненте. Чтобы передать заголовок нашему компоненту записи блога, мы должны объявить его в списке входных параметров, которые принимают этот компонент, используя макрос [`defineProps`](https://ru.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits):
```js
<!-- BlogPost.vue -->
<script setup>
defineProps(['title'])
</script>

<template>
  <h4>{{ title }}</h4>
</template>
```
`defineProps` макрос компилятора используемый только внутри `<script setup>` и не нуждается в явном импорте. Объявленные входные параметры автоматически отображаются в шаблоне. `defineProps` также возвращает объект, содержащий все входные параметры, переданные компоненту, чтобы при необходимости мы могли получить к ним доступ в JavaScript:
```js
const props = defineProps(['title'])
console.log(props.title)
```
Если вы не используете `<script setup>`, входные параметры должны быть объявлены с помощью опции `props`, и объект _props_ будет передан `setup()` в качестве первого аргумента:
```js
export default {
  props: ['title'],
  setup(props) {
    console.log(props.title)
  }
}
```
После регистрации входного параметра вы можете передавать ему данные в качестве пользовательского атрибута, как показано ниже:

```js
<BlogPost title="Как изучить Vue" />
<BlogPost title="Ведение блога с помощью Vue" />
<BlogPost title="Почему Vue так интересен" />
```
## Прослушивание событий
По мере разработки нашего компонента `<BlogPost>`, некоторые функции могут потребовать обратной связи с родительским компонентом.Например, мы можем решить включить функцию доступности для увеличения текста записей блога, оставляя при этом размер остальной части страницы по умолчанию.
В родителе мы можем включить эту функцию, добавив свойство `postFontSize`:
```js
const posts = ref([
  /* ... */
])

const postFontSize = ref(1)
```
Которая может использоваться в шаблоне для управления размером шрифта всех записей блога:`
```js
<div :style="{ fontSize: postFontSize + 'em' }">
  <BlogPost
    v-for="post in posts"
    :key="post.id"
    :title="post.title"
   />
</div>
```
Теперь давайте добавим кнопку в шаблон компонента `<BlogPost>`:
```js
<!-- BlogPost.vue, не добавлен <script> -->
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button>Увеличить размер текста</button>
  </div>
</template>
```
При нажатии на кнопку нужно сообщить родительскому компоненту, чтобы увеличил размер текста для всех записей блога. Для решения этой проблемы, экземпляры компонента предоставляют собственную систему событий. Родительский компонент может прослушивать любые события на экземпляре дочернего компонента с помощью `v-on` или `@`, аналогично отслеживанию нативных событий DOM:
```js
<BlogPost
  ...
  @enlarge-text="postFontSize += 0.1"
 />
```
Тогда дочерний компонент может сгенерировать событие с помощью встроенного [метода `$emit`](https://ru.vuejs.org/api/component-instance.html#emit), передавая ему имя события:
```js
<!-- BlogPost.vue, не добавлен <script> -->
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button @click="$emit('enlarge-text')">Увеличить размер текста</button>
  </div>
</template>
```
Благодаря прослушиванию события `@enlarge-text="postFontSize += 0.1"`, родительский компонент отследит событие и обновится со значением `postFontSize`.

Все генерируемые компонентом события можно перечислить в [`defineEmits`](https://ru.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits):
Это позволит проверять все события, которые генерирует компонент, и опционально [валидировать их](https://ru.vuejs.org/guide/components/events.html#events-validation). Это также позволяет Vue избежать неявного применения их в качестве нативных слушателей к корневому элементу дочернего компонента.

Как и `defineProps`, `defineEmits` используется только в `<script setup>` и не требует импорта. defineEmits возвращает функцию `emit`, которая эквивалентна методу `$emit`. Её можно использовать для генерации событий в разделе компонента `<script setup>`, где `$emit` недоступен напрямую:
```js
<script setup>
const emit = defineEmits(['enlarge-text'])

emit('enlarge-text')
</script>
```
Если вы не используете `<script setup>`, вы можете объявить эмитируемые события с помощью опции `emits`. Вы можете получить доступ к функции `emit` как к свойству контекста настройки (передается в `setup()` в качестве второго аргумента):
```js
export default {
  emits: ['enlarge-text'],
  setup(props, ctx) {
    ctx.emit('enlarge-text')
  }
}
```
## Распределение контента слотами
Как и в случае с обычными HTML-элементами, часто бывает полезным иметь возможность передавать компоненту содержимое, например таким образом:
```js
<AlertBox>
  Произошло что-то плохое.
</AlertBox>
```
Такого можно добиться при помощи пользовательского элемента `<slot>` у Vue:
```js
<!-- AlertBox.vue -->
<template>
  <div class="alert-box">
    <strong>Эта ошибка для демонстрационных целей</strong>
    <slot />
  </div>
</template>

<style scoped>
.alert-box {
  /* ... */
}
</style>
```
Как можно увидеть выше, `<slot>` будет использоваться в качестве места, куда потребуется подставлять контент — и это всё. Готово!
## Динамические компоненты
Иногда бывает полезным динамически переключаться между компонентами, как например в интерфейсе с вкладками. Это возможно сделать с помощью элемента `<component>` со специальным атрибутом `is`:
```js
<!-- Компонент будет меняться при изменении currentTab -->
<component :is="tabs[currentTab]"></component>
```
В примере выше значением `:is` может быть:

- имя зарегистрированного компонента, или
- объект с настройками компонента

Можно также использовать атрибут `is` и для создания обычных HTML-элементов.

При переключении между несколькими компонентами с помощью `<component :is="...">`, компонент будет размонтирован при отключении от него. Мы можем заставить неактивные компоненты оставаться "живыми" с помощью встроенного [компонента `<KeepAlive>`](https://ru.vuejs.org/guide/built-ins/keep-alive.html).