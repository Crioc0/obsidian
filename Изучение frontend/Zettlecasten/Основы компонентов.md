2025 06 2818 28
Tags: #vue 
###### Links: 
1) 
# Заметка
Компоненты позволяют разбить пользовательский интерфейс на независимые и многократно используемые части и думать о каждой части по отдельности. Обычно приложение организовано в виде дерева вложенных друг в друга компонентов
## Определение компонента
При использовании шага сборки мы обычно определяем каждый компонент Vue в отдельном файле с расширением `.vue` - это называется [однофайловый компонент](https://ru.vuejs.org/guide/scaling-up/sfc.html) (по англ. Single-File Component или, сокращённо, SFC):
```js
<script setup>
import { ref } from 'vue'

const count = ref(0)
</script>

<template>
  <button @click="count++">Вы нажали на меня {{ count }} раз.</button>
</template>
```
Если не использовать шаг сборки, компонент Vue можно определить как обычный объект JavaScript, содержащий специфические для Vue опции:
```js
import { ref } from 'vue'

export default {
  setup() {
    const count = ref(0)
    return { count }
  },
  template: `
    <button @click="count++">
      Вы нажали на меня {{ count }} раз.
    </button>`
  // Can also target an in-DOM template:
  // template: '#my-template-element'
}
```
## Использование компонента
Чтобы использовать дочерний компонент, мы должны импортировать его в родительский компонент. Если мы разместили наш компонент счётчика в файле под названием `ButtonCounter.vue`, то компонент будет экспортирован в файл по умолчанию:
```js
<script setup>
import ButtonCounter from './ButtonCounter.vue'
</script>

<template>
  <h1>Здесь дочерний компонент!</h1>
  <ButtonCounter />
</template>
```
С помощью `<script setup>`, импортированные компоненты автоматически становятся доступными для шаблона.

Также можно глобально зарегистрировать компонент, сделав его доступным для всех компонентов данного приложения без необходимости его импорта.

В SFC рекомендуется использовать имена тегов для дочерних компонентов в регистре `PascalCase`, чтобы отличить их от собственных элементов HTML. Хотя имена тегов HTML не чувствительны к регистру, Vue SFC - это скомпилированный формат, поэтому мы можем использовать в нем имена тегов с учетом регистра. Мы также можем использовать `/>` для закрытия тега.

Если вы создаете свои шаблоны непосредственно в DOM (например, как содержимое собственного элемента `<template>`), то шаблон будет подчиняться собственному поведению браузера при разборе HTML. В таких случаях необходимо использовать регистр `kebab-case` и явные закрывающие теги для компонентов:
```js
<!-- если этот шаблон записан в DOM -->
<button-counter></button-counter>
<button-counter></button-counter>
<button-counter></button-counter>
```
## Передача входных параметров
Входные параметры — это настраиваемые атрибуты, которые вы можете зарегистрировать в компоненте. Чтобы передать заголовок нашему компоненту записи блога, мы должны объявить его в списке входных параметров, которые принимают этот компонент, используя макрос [`defineProps`](https://ru.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits):
```js
<!-- BlogPost.vue -->
<script setup>
defineProps(['title'])
</script>

<template>
  <h4>{{ title }}</h4>
</template>
```
`defineProps` макрос компилятора используемый только внутри `<script setup>` и не нуждается в явном импорте. Объявленные входные параметры автоматически отображаются в шаблоне. `defineProps` также возвращает объект, содержащий все входные параметры, переданные компоненту, чтобы при необходимости мы могли получить к ним доступ в JavaScript:
```js
const props = defineProps(['title'])
console.log(props.title)
```
Если вы не используете `<script setup>`, входные параметры должны быть объявлены с помощью опции `props`, и объект _props_ будет передан `setup()` в качестве первого аргумента:
```js
export default {
  props: ['title'],
  setup(props) {
    console.log(props.title)
  }
}
```
После регистрации входного параметра вы можете передавать ему данные в качестве пользовательского атрибута, как показано ниже:

```js
<BlogPost title="Как изучить Vue" />
<BlogPost title="Ведение блога с помощью Vue" />
<BlogPost title="Почему Vue так интересен" />
```
## Прослушивание событий
По мере разработки нашего компонента `<BlogPost>`, некоторые функции могут потребовать обратной связи с родительским компонентом.