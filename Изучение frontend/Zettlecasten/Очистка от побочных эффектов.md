2025 06 2818 16
Tags: #vue 
###### Links: 
1) [[Наблюдатели]]
# Заметка
Иногда мы можем получить побочные эффекты, например при асинхронных запросах:
```js
watch(id, (newId) => {
  fetch(`/api/${newId}`).then(() => {
    // callback logic
  })
})
```
Но что, если `id` изменится до завершения запроса? Когда запрос завершится, мы получим данные с предыдущем запрошенным значением. В идеале, мы хотим иметь возможность отменить запрос, при изменении `id`.

Мы можем использовать [`onWatcherCleanup()`](https://ru.vuejs.org/api/reactivity-core.html#onwatchercleanup)  API для регистрации функции очистки, которая будет вызываться, когда наблюдатель становится недействительным и собирается перезапуститься:
```js
import { watch, onWatcherCleanup } from 'vue'

watch(id, (newId) => {
  const controller = new AbortController()

  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // callback logic
  })

  onWatcherCleanup(() => {
    // abort stale request
    controller.abort()
  })
})
```
Обратите внимание, что `onWatcherCleanup` поддерживается только в Vue 3.5+ и должен вызываться во время синхронного вызова функции эффекта `watchEffect` или обратного вызова `watch`. Ты не сможешь его вызвать после `await` в асинхронной функции.

Альтернативно, функция `onCleanup` передается в коллбэк `watch` в качестве третьего аргумента, и в коллбэк `watchEffect` в качестве первого аргумента: