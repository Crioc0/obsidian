2025 06 2914 43
Tags: #vue 
###### Links: 
1) 
# Заметка
Когда мы передаём деструктурированное свойство в функцию, например:
```js
const { foo } = defineProps(['foo'])

watch(foo, /* ... */)
```
Это не будет работать так, как ожидалось, потому что это эквивалентно `watch(props.foo, ...)` - мы передаем значение, а не реактивный источник данных в `watch`.
Подобно тому, как мы можем наблюдать за обычным свойством с помощью `watch(() => props.foo, ...)`, мы можем наблюдать за деструктурированным свойством, обернув его в геттер.
```js
watch(() => foo, /* ... */)
```
Кроме того, это рекомендуемый подход, когда нам нужно передать деструктурированное свойство во внешнюю функцию, сохранив при этом реактивность:
```js
useComposable(() => foo)
```
Внешняя функция может вызвать геттер (или нормализовать его с помощью [toValue](https://ru.vuejs.org/api/reactivity-utilities.html#tovalue)) когда ей нужно отследить изменения предоставленного свойства, например, в вычисляемом или наблюдающем геттере.