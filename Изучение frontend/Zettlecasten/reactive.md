2025 07 0611 20
Tags: #vue 
###### Links: 
1) [[Ref и reactive]]
# Заметка
Возвращает реактивную копию объекта.
**Тип**
```js
function reactive<T extends object>(target: T): UnwrapNestedRefs<T>
```
**Подробности**
Реактивное преобразование является глубоким-оно влияет на все вложенные свойства. Реактивный объект также глубоко развертывает все свойства.  Реактивный объект также глубоко развертывает любые свойства, которые являются ref - объектами, сохраняя реактивность.
Следует также отметить, что развертывание ref-объекта не выполняется, когда к нему обращаются как к элементу реактивного массива или нативной коллекции, например `Map`.
Чтобы избежать глубокого преобразования и сохранить реактивность только на корневом уровне, нужно использовать shallowReactive
Возвращаемый объект и его вложенные объекты обёрнуты в ESProxy и не равны исходным объектам. Рекомендуется работать исключительно с реактивными proxy-объектом и не полагаться на исходный объект
**Пример**

Создание реактивного объекта:
```js
const obj = reactive({ count: 0 })
obj.count++
```
Развертывание ref-объекта:
```js
const count = ref(1)
const obj = reactive({ count })

// ref-объект будет развернут
console.log(obj.count === count.value) // true

// это также обновит `obj.count`
count.value++
console.log(count.value) // 2
console.log(obj.count) // 2

// это также обновит ref-объект count
obj.count++
console.log(obj.count) // 3
console.log(count.value) // 3
```