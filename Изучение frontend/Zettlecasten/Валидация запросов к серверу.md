2025 09 2312 40
Tags: #mongoose 
###### Links: 
1) 
# Заметка
Чтобы уменьшить вероятность атаки, нужно уменьшить количество шагов между получением запроса от пользователя до валидации. Для этого мы можем валидировать запросы до того, как они попадут в контроллер: проверить тело запроса, его заголовки и только затем пропускать его в контроллер. Если запрос не прошёл валидацию, сразу вернём пользователю ошибку. Таким образом, мы сильно ограничим возможности злоумышленника использовать потенциальные ошибки в коде
## Joi и celebrate
Существует множество инструментов и библиотек для валидации данных в Node.js, такие как `ajv`, `fastest-validator` и `celebrate`. Мы остановимся на последнем, и вот почему: `celebrate` легко интегрируется в проект на Express и «под капотом» использует проверенную временем библиотеку валидации `joi`.
```ts
const { celebrate, Joi } = require('celebrate');

router.post('/posts', celebrate({
  body: Joi.object().keys({
    title: Joi.string().required().min(2).max(30),
    text: Joi.string().required().min(2),
  }),
}), createPost);
```
По умолчанию Joi не допускает полей, которые не перечислены в объекте валидации. Чтобы изменить это поведение, нужно после вызова метода `keys` вызвать метод `unknown` с аргументом `true`
```ts
const { celebrate, Joi } = require('celebrate');

router.delete('/:postId', celebrate({
  headers: Joi.object().keys({
    // валидируем заголовки
  }).unknown(true),
}), deletePost);
```
## Ошибки
Если запрос не проходит описанную валидацию, celebrate передаст его дальше, но не в контроллер, а в обработчик ошибки.

Мы можем описать логику обработки таких ошибок самостоятельно при помощи соответствующей проверки и метода **`isCelebrateError(err)`**, но мы пойдём другим путём и воспользуемся готовым мидлваром `errors`.

Мидлвар `errors()` будет обрабатывать только ошибки, которые сгенерировал celebrate. Все остальные ошибки он передаст дальше, где их перехватит централизованный обработчик.

400 — статус ошибки, которую возвращает celebrate, а тело ответа имеет такой вид: