2025 06 3016 46
Tags: #vue 
###### Links: 
1) 
# Заметка
### Именование
По соглашению composable функции называются именами в camelCase, которые начинаются с "use".
### Входные аргументы
Composable может принимать ref-аргументы, даже если он не полагается на них для обеспечения реактивности. Если вы пишете composable, который может быть использован другими разработчиками, то неплохо было бы предусмотреть случай, когда входными аргументами являются не сырые значения, а refs. Для этого пригодится служебная функция [`toValue()`](https://ru.vuejs.org/api/reactivity-utilities.html#tovalue)
```js
import { toValue } from 'vue'

function useFeature(maybeRefOrGetter) {
  // Если maybeRefOrGetter является ref-ссылкой или геттером,
  // будет возвращено его нормализованное значение.
  // В противном случае, будет возвращено "как есть".
  const value = toValue(maybeRefOrGetter)
}
```
### Возвращаемые значения
В composables нужно использовать исключительно ref(), а не reactive(). Рекомендуется, чтобы composables всегда возвращали обычный нереактивный объект, содержащий несколько ссылок. Это позволяет деструктурировать его в компонентах, сохраняя реактивность:
```js
// x и y являются refs
const { x, y } = useMouse()
```

Если вы предпочитаете использовать возвращаемое состояние из composables в качестве свойств объекта, вы можете обернуть возвращаемый объект с помощью `reactive()` так, чтобы refs были развернуты. Например:
```js
const mouse = reactive(useMouse())
// mouse.x связан с оригинальным ref
console.log(mouse.x)
```
### Побочные эффекты
Выполнять побочные эффекты (например, добавлять слушателей событий DOM или получать данные) в composables можно, но при этом следует обратить внимание на следующие правила:
- Если вы работаете над приложением, использующим [отрисовку на стороне сервера](https://ru.vuejs.org/guide/scaling-up/ssr.html) (SSR), обязательно выполняйте побочные эффекты, специфичные для DOM, в хуках жизненного цикла после монтирования, например, `onMounted()`. Эти хуки вызываются только в браузере, поэтому вы можете быть уверены, что код, находящийся в них, имеет доступ к DOM.
    
- Не забывайте очищать побочные эффекты в `onUnmounted()`. Например, если компонент устанавливает слушатель событий DOM, он должен удалить этот слушатель в `onUnmounted()`, как мы видели в примере `useMouse()`. Хорошей идеей может быть использование composable, который автоматически делает это за вас, как пример `useEventListener()`.
### Ограничения в использовании
Composables должны вызываться только **синхронно** в `<script setup>` или в хуке `setup()`. В некоторых случаях их можно также вызывать в хуках жизненного цикла, например `onMounted()`.

Эти ограничения важны, потому что именно в этих контекстах Vue может определить текущий активный экземпляр компонента. Доступ к активному экземпляру компонента необходим для того, чтобы:

1. На него могут быть зарегистрированы хуки жизненного цикла.
    
2. Вычисляемые свойства и наблюдатели могут быть связаны с ним, чтобы их можно было утилизировать при размонтировании экземпляра для предотвращения утечек памяти.
    

Совет

`<script setup>` это единственное место, где можно вызывать composables **после** использования `await`. Компилятор автоматически восстанавливает активный контекст экземпляра после выполнения операции async.