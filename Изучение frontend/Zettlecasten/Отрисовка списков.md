2025 06 2816 43
Tags: #vue 
###### Links: 
1) [[Условный рендеринг]]
# Заметка
Для отрисовки элементов на основе массива можно использовать директиву v-for.
У директивы `v-for` специальный синтаксис: `item in items`, где `items` — исходный массив, а `item` — **ссылка** на итерируемый элемент массива
```js
const items = ref([{ message: 'Foo' }, { message: 'Bar' }])

<li v-for="item in items">
  {{ item.message }}
</li>
```
Также есть возможность получить index
```js
const parentMessage = ref('Родитель')
const items = ref([{ message: 'Foo' }, { message: 'Bar' }])

<li v-for="(item, index) in items">
  {{ parentMessage }} - {{ index }} - {{ item.message }}
</li>
```
## Отображение свойств объекта
v-for можно использовать для итерации по свойствам объекта.  Порядок итерации будет основан на результате вызова `Object.values()` для объекта
```js
const myObject = reactive({
  title: 'How to do lists in Vue',
  author: 'Jane Doe',
  publishedAt: '2016-04-10'
})
```

```js
<ul>
  <li v-for="value in myObject">
    {{ value }}
  </li>
</ul>
```
Также можно указать второй аргумент для получения свойства объекта (key) и индекса (index)
## v-for и диапазоны
Можно передавать целое число в `v-for` — шаблон будет повторяться указанное число раз.
```js
<span v-for="n in 10">{{ n }}</span>
```

## v-for и template
Аналогично с v-if,  можно использовать тег template с v-for для отрисовки блоков из нескольких элементов
```js
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>
```
## v-if и template
Когда они указаны вместе на одном узле, у `v-if` будет больший приоритет, чем у `v-for`. И поэтому в условии `v-if` не будет доступа к переменным из области видимости `v-for`
Для ясности лучше переместить v-for на тег-обертку template
```js
<!--
Будет выброшена ошибка, так как свойство "todo" не объявлено в экземпляре.
-->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>

<template v-for="todo in todos">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```

## Сохранение состояния с помощью `key`
При обновлении Vue списка элементов, отрисованного директивой `v-for`, по умолчанию используется стратегия обновления «на месте». Если порядок элементов массива или объекта изменился, Vue не станет перемещать элементы DOM, а просто обновит каждый элемент «на месте», чтобы он отображал новые данные по соответствующему индексу.

Режим по умолчанию эффективен, но **применим только в случаях, когда результат отрисовки списка не полагается на состояние дочерних компонентов или временное состояние DOM (например, значения в полях форм)**.

Чтобы подсказать Vue, как определять идентичность каждого элемента, и, таким образом, переиспользовать и упорядочивать существующие элементы, необходимо указать уникальный атрибут `key` для каждого элемента:
```js
<div v-for="item in items" :key="item.id">
  <!-- Содержимое -->
</div>
```
При использовании `<template v-for>` атрибут `key` нужно устанавливать на контейнер `<template>`:
```js
<template v-for="todo in todos" :key="todo.name">
  <li>{{ todo.name }}</li>
</template>
```
Рекомендуется всегда указывать атрибут `key` с `v-for`, кроме случаев когда итерируемое содержимое DOM простое (т.е. не содержит компонентов или элементов DOM с состоянием), или когда сознательно полагаетесь на стратегию обновления по умолчанию для улучшения производительности.

## `v-for` и компоненты
Можно использовать `v-for` на компонентах, как на обычных элементах (не забывайте указать `key`):
```js
<MyComponent v-for="item in items" :key="item.id" />
```
В компоненты никакие данные автоматически передаваться не будут, поскольку у каждого компонента своя область видимости. Чтобы передать итерируемые данные в компонент потребуется явно использовать входные параметры: 
```js
<MyComponent
  v-for="(item, index) in items"
  :item="item"
  :index="index"
  :key="item.id"
/>
```